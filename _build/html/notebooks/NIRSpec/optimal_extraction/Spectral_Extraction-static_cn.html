
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>MOS 最优光谱提取 &#8212; STScI JDAT Notebooks 中文版</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/main.css?v=b44a18d9" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/NIRSpec/optimal_extraction/Spectral_Extraction-static_cn';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="星系外场的MOS光谱" href="../mos_spectroscopy_advanced/MOSspec_advanced_cn.html" />
    <link rel="prev" title="NIRSpec IFU 最优点源提取" href="../ifu_optimal/ifu_optimal_cn.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/stsci_logo2.png" class="logo__image only-light" alt="STScI JDAT Notebooks 中文版 - Home"/>
    <script>document.write(`<img src="../../../_static/stsci_logo2.png" class="logo__image only-dark" alt="STScI JDAT Notebooks 中文版 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../intro.html">
                    
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">通用</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">主页</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install_cn.html">安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/notebook_development_workflow_cn.html">笔记本开发工作流程</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">开发</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../docs/submitting_notebooks_cn.html">提交笔记本</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/requirements_cn.html">需求文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/notebooks_cn.html">Jupyter 笔记本</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/data_files_cn.html">数据文件</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">GitHub 指南</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../docs/github_setup_cn.html">GitHub 设置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/github_workflow_cn.html">GitHub 工作流程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/github_pr_cn.html">GitHub PR</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">跨仪器通用</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../cross_instrument/asdf_example/asdf_example_cn.html">ASDF 示例</a></li>

<li class="toctree-l1"><a class="reference internal" href="../../cross_instrument/background_estimation_imaging/Imaging_Sky_Background_Estimation_cn.html">复杂的二维背景</a></li>

<li class="toctree-l1"><a class="reference internal" href="../../cross_instrument/composite_model_fitting/specfit_demo_3_cn.html">复合模型光谱拟合</a></li>


<li class="toctree-l1"><a class="reference internal" href="../../cross_instrument/NIRSpec_MAST_Query/NIRSpec_MAST_Query_cn.html">MAST 查询</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cross_instrument/rgb_imviz/imviz_rgb_carina_cn.html">Imviz RGB图像</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cross_instrument/specviz_notebookGUI_interaction/specviz_notebook_gui_interaction_redshift_cn.html">Specviz 简单示例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cross_instrument/update_pure_parallel_wcs/NIRISS_correct_pure_parallel_WCS_cn.html">提高纯平行数据集的WCS精度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cross_instrument/stpsf_examples/stpsf_examples_cn.html">STPSF 示例</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">MIRI</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../MIRI/MRS_Mstar_analysis/JWST_Mstar_dataAnalysis_analysis_cn.html">MRS Mstar - 数据分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MIRI/MIRI_IFU_YSOs_in_the_LMC/isha_nayak_ysos_in_the_lmc_cn.html">LMC中的IFU YSOs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MIRI/MIRI_LRS_spectral_extraction/miri_lrs_advanced_extraction_part1_cn.html">LRS 光谱提取</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">NIRCam</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../NIRCam/aperture_photometry/NIRCam_Aperture_Photometry_Example_cn.html">点源光度测量</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NIRCam/NIRCam_photometry/NIRCam_multiband_photometry_cn.html">扩展孔径光度测量</a></li>


<li class="toctree-l1"><a class="reference internal" href="../../NIRCam/NIRCam_PSF-matched_photometry/NIRCam_PSF_matched_multiband_photometry_cn.html">交叉滤光片 PSF 匹配</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NIRCam/psf_photometry/NIRCam_PSF_Photometry_Example_cn.html">PSF 光度测量</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NIRCam/NIRCam_wisp_subtraction/nircam_wisp_subtraction_cn.html">NIRCam 光晕去除</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">NIRISS</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../NIRISS/NIRISS_WFSS_postpipeline/00_Optimal_extraction_cn.html">WFSS 光谱 - 提取</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NIRISS/NIRISS_WFSS_postpipeline/01_Combine_and_normalize_1D_spectra_cn.html">WFSS 光谱 - 合并和归一化 1D 光谱</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NIRISS/NIRISS_WFSS_postpipeline/02_Cross_correlation_template_cn.html">WFSS 光谱 - 相关性模版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NIRISS/NIRISS_WFSS_postpipeline/03_Spatially_resolved_emission_line_map_cn.html">WFSS 光谱 - 发射线图</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NIRISS/NIRISS_WFSS_advanced/00_niriss_mast_query_data_setup_cn.html">NIRISS MAST</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NIRISS/NIRISS_WFSS_advanced/01_niriss_wfss_image2_image3_cn.html">运行图像处理管道并创建源目录</a></li>

<li class="toctree-l1"><a class="reference internal" href="../../NIRISS/NIRISS_WFSS_advanced/02_niriss_wfss_spec2_cn.html">运行 spec2 管道</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">NIRSpec</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../IFU_cube_continuum_fit/NGC4151_FeII_ContinuumFit_cn.html">IFU立方体拟合</a></li>




<li class="toctree-l1"><a class="reference internal" href="../cube_fitting/cube_fitting_cn.html">IFU Cube 建模</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ifu_optimal/ifu_optimal_cn.html">IFU 光谱提取</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">MOS 提取</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mos_spectroscopy_advanced/MOSspec_advanced_cn.html">星系外场的MOS光谱</a></li>

<li class="toctree-l1"><a class="reference internal" href="../transit_spectroscopy_notebook/Exoplanet_Transmission_Spectra_JWST_cn.html">BOTS 时间序列观测</a></li>








<li class="toctree-l1"><a class="reference internal" href="../galaxy_redshift/redshift_fitting_cn.html">红移和模板拟合</a></li>
<li class="toctree-l1"><a class="reference internal" href="../NIRSpec_NSClean/FS_NSClean_example_cn.html">FS 数据生成 （NSClean）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../NIRSpec_NSClean/IFU_NSClean_example_cn.html">IFU 数据生成 （NSClean）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../NIRSpec_NSClean/MOS_NSClean_example_cn.html">MOS 数据生成 （NSClean）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../NIRSpec_NSClean/BOTS_NSClean_example_cn.html">BOTS 数据生成 （NSClean）</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/notebooks/NIRSpec/optimal_extraction/Spectral_Extraction-static_cn.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>MOS 最优光谱提取</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">引言</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">定义术语</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">导入库</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">加载数据</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">最优提取算法</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">定义提取区域</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">创建核切片</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">定义提取核</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#psf">选择一个PSF模板</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">多项式背景</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">拟合提取核</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fwhm">波长变化的全宽半最大值 (FWHM)（已跳过）</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">拟合几何畸变 <em>(跳过)</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">定义轨迹拟合的区间</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">使用修改后的提取核拟合每个箱体</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">使用一维多项式拟合轨迹中心</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#d">构建最终的1D光谱</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">创建方差图像</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">生成一维光谱</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a">附录 A：批处理</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">定义提取区域</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">创建核切片</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">创建并拟合提取核</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">考虑变化的全宽半最大值（FWHM）</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">拟合轨迹中心</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">生成一维光谱</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">便利函数</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">遍历所需文件</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">在示例数据集上运行</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#b-stpsf">附录 B: STPSF</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id26">仪器属性</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#psfs">单色点扩散函数（PSFs）</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id27">插值方法</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id28">完整的轨迹点扩散函数 (PSF)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id29">重采样轨迹</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id30">关于这个笔记本</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="mos">
<h1>MOS 最优光谱提取<a class="headerlink" href="#mos" title="Link to this heading">#</a></h1>
<p><strong>用例：</strong> 最优光谱提取；方法参考 <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/1986PASP...98..609H/abstract">Horne (1986)</a>。<br></p>
<p><strong>数据：</strong> JWST 模拟的 NIRSpec MOS 数据；点源。<br></p>
<p><strong>工具：</strong> jwst, stpsf, matplotlib, scipy, 自定义函数。<br></p>
<p><strong>跨仪器：</strong> 任何光谱仪。<br></p>
<p><strong>文档：</strong> 本笔记本是 STScI 更大 <a class="reference external" href="https://jwst-docs.stsci.edu/jwst-post-pipeline-data-analysis">后处理数据分析工具生态系统</a> 的一部分。<br></p>
<section id="id1">
<h2>引言<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<p>JWST 流水线为每种光谱模式生成来自组合曝光的 1-D 和 2-D 矫正光谱。目前，1D 产品是通过光圈提取生成的，计划通过 PSF 加权或拟合来实现最优提取。然而，在许多情况下，输出结果不一定是“最优”的，因此需要微调参数以改善结果。本笔记本旨在提供最优提取过程的逐步指导，并使用示例 JWST 数据进行说明。</p>
</section>
<section id="id2">
<h2>定义术语<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p><strong>最优提取：</strong> 一种首次由 <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/1986PASP...98..609H/">Horne (1986)</a> 定义的光圈提取方法。<br></p>
<p><strong>S/N：</strong> 信噪比，衡量光谱噪声程度的指标。<br></p>
<p><strong>WCS：</strong> 世界坐标系统，用于在不同参考框架之间转换。<br></p>
</section>
<section id="id3">
<h2>导入库<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>我们将使用以下库来执行最优光谱提取。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">glob</span> <span class="pre">glob</span></code> 用于收集文件名</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span></code> 用于处理数组函数以及其他各种活动</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jwst.datamodels</span> <span class="pre">ImageModel,</span> <span class="pre">MultiSpecModel</span></code> 用于访问示例数据的数模</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">astropy.io</span> <span class="pre">fits</span></code> 用于低级 FITS 文件输入输出</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">astropy.modeling</span> <span class="pre">models,</span> <span class="pre">fitting</span></code> 用于许多拟合任务</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">astropy.visualization</span> <span class="pre">astropy_mpl_style,</span> <span class="pre">simple_norm</span></code> 用于显示美观的图像</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scipy.interpolate</span> <span class="pre">interp1d,</span> <span class="pre">RegularGridInterpolator</span></code> 用于所有插值需求</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> 用于绘制数据</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matplotlib.patches</span> <span class="pre">Rectangle</span></code> 用于在数据上绘制矩形</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stpsf</span> <span class="pre">NIRSpec</span></code> 用于生成和可视化来自仪器模型的 PSF（见附录 B）</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline  # 在Jupyter Notebook中内联显示matplotlib图形

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>  <span class="c1"># 导入os模块，用于处理文件和目录</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">tarfile</span>  <span class="c1"># 导入tarfile模块，用于处理tar文件</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">zipfile</span>  <span class="c1"># 导入zipfile模块，用于处理zip文件</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">urllib.request</span>  <span class="c1"># 导入urllib.request模块，用于处理URL请求</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">urllib.parse</span><span class="w"> </span><span class="kn">import</span> <span class="n">urlparse</span>  <span class="c1"># 从urllib.parse导入urlparse，用于解析URL</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>  <span class="c1"># 导入requests库，用于发送HTTP请求</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">glob</span><span class="w"> </span><span class="kn">import</span> <span class="n">glob</span>  <span class="c1"># 从glob导入glob，用于文件路径匹配</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>  <span class="c1"># 导入numpy库，用于数值计算</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">stdatamodels.jwst.datamodels</span><span class="w"> </span><span class="kn">import</span> <span class="n">ImageModel</span>  <span class="c1"># 从stdatamodels导入JWST图像数据模型</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">fits</span>  <span class="c1"># 从astropy.io导入fits模块，用于处理FITS文件</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.modeling</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span><span class="p">,</span> <span class="n">fitting</span>  <span class="c1"># 从astropy.modeling导入模型和拟合工具</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.visualization</span><span class="w"> </span><span class="kn">import</span> <span class="n">astropy_mpl_style</span><span class="p">,</span> <span class="n">simple_norm</span>  <span class="c1"># 导入可视化样式和简单归一化工具</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span><span class="p">,</span> <span class="n">RegularGridInterpolator</span>  <span class="c1"># 从scipy.interpolate导入插值工具</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>  <span class="c1"># 导入matplotlib.pyplot，用于绘图</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rectangle</span>  <span class="c1"># 从matplotlib.patches导入Rectangle，用于绘制矩形</span>

<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="n">astropy_mpl_style</span><span class="p">)</span>  <span class="c1"># 使用导入的样式设置matplotlib的显示风格</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>  <span class="c1"># 导入os模块，用于操作系统相关功能</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>  <span class="c1"># 导入requests模块，用于发送HTTP请求</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tarfile</span>  <span class="c1"># 导入tarfile模块，用于处理tar文件</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">urllib.parse</span><span class="w"> </span><span class="kn">import</span> <span class="n">urlparse</span>  <span class="c1"># 导入urlparse，用于解析URL</span>

<span class="c1"># 设置环境变量</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;STPSF_PATH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;./data/stpsf-data&quot;</span>  <span class="c1"># 设置STPSF数据的路径</span>

<span class="c1"># STPSF数据的URL和文件路径</span>
<span class="n">stpsf_url</span> <span class="o">=</span> <span class="s1">&#39;https://stsci.box.com/shared/static/kqfolg2bfzqc4mjkgmujo06d3iaymahv.gz&#39;</span>  <span class="c1"># STPSF数据的下载链接</span>
<span class="n">stpsf_file</span> <span class="o">=</span> <span class="s1">&#39;./stpsf-data-LATEST.tar.gz&#39;</span>  <span class="c1"># 下载后的文件名</span>
<span class="n">stpsf_folder</span> <span class="o">=</span> <span class="s2">&quot;./data&quot;</span>  <span class="c1"># 存放解压后文件的文件夹</span>

<span class="c1"># 定义下载文件的函数</span>
<span class="k">def</span><span class="w"> </span><span class="nf">download_file</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">dest_path</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
    <span class="n">parsed_url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>  <span class="c1"># 解析URL</span>

    <span class="c1"># 检查URL的协议是否支持</span>
    <span class="k">if</span> <span class="n">parsed_url</span><span class="o">.</span><span class="n">scheme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;http&quot;</span><span class="p">,</span> <span class="s2">&quot;https&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported URL scheme: </span><span class="si">{</span><span class="n">parsed_url</span><span class="o">.</span><span class="n">scheme</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># 抛出不支持的协议错误</span>

    <span class="c1"># 发送GET请求下载文件</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>  <span class="c1"># 以流的方式下载文件</span>
    <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>  <span class="c1"># 检查请求是否成功</span>

    <span class="c1"># 将下载的内容写入目标文件</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dest_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>  <span class="c1"># 以二进制写入模式打开文件</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">iter_content</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">8192</span><span class="p">):</span>  <span class="c1"># 分块读取内容</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>  <span class="c1"># 写入文件</span>

<span class="c1"># 检查STPSF文件夹是否存在</span>
<span class="n">stpsfExist</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stpsf_folder</span><span class="p">)</span>  <span class="c1"># 检查文件夹是否存在</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">stpsfExist</span><span class="p">:</span>  <span class="c1"># 如果文件夹不存在</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">stpsf_folder</span><span class="p">)</span>  <span class="c1"># 创建文件夹</span>
    <span class="n">download_file</span><span class="p">(</span><span class="n">stpsf_url</span><span class="p">,</span> <span class="n">stpsf_file</span><span class="p">)</span>  <span class="c1"># 下载STPSF数据文件</span>
    <span class="n">gzf</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">stpsf_file</span><span class="p">)</span>  <span class="c1"># 打开下载的tar文件</span>
    <span class="n">gzf</span><span class="o">.</span><span class="n">extractall</span><span class="p">(</span><span class="n">stpsf_folder</span><span class="p">)</span>  <span class="c1"># 解压文件到指定文件夹</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id4">
<h2>加载数据<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>我们将使用James Muzerolle提供的模拟级别3 MOS数据。这些文件来自一次包含多个点源的模拟访问，我们将从<code class="docutils literal notranslate"><span class="pre">resample</span></code>步骤的产品开始，这些文件的扩展名为<code class="docutils literal notranslate"><span class="pre">s2d.fits</span></code>。我们还将比较我们的最佳提取结果与<code class="docutils literal notranslate"><span class="pre">extract1d</span></code>步骤的产品，后者的扩展名为<code class="docutils literal notranslate"><span class="pre">x1d.fits</span></code>。有关这些文件的结构和格式的详细信息，请参见<a class="reference external" href="https://jwst-pipeline.readthedocs.io/en/stable/jwst/data_products/product_types.html#stage-3-data-products">科学数据产品规范</a>及其中的链接。</p>
<p>下面列出的最佳提取程序可以针对每个 <code class="docutils literal notranslate"><span class="pre">s2d</span></code> 文件中的每个 <code class="docutils literal notranslate"><span class="pre">'SCI'</span></code> 扩展重复进行。为了本笔记本的目的，我们将假设 <code class="docutils literal notranslate"><span class="pre">resample</span></code> 步骤已产生最佳输出，因此我们只需要访问这些扩展。（校正和组合输入光谱本身是一个复杂的过程，远超出本笔记本的范围！）</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 如果示例数据集已经下载，请注释掉这些行：</span>

<span class="n">boxlink</span> <span class="o">=</span> <span class="s1">&#39;https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/optimal_extraction/optimal_extraction.zip&#39;</span>  <span class="c1"># 数据集的下载链接</span>

<span class="n">boxfile</span> <span class="o">=</span> <span class="s1">&#39;./optimal_extraction.zip&#39;</span>  <span class="c1"># 下载后保存的文件名</span>

<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="n">boxlink</span><span class="p">,</span> <span class="n">boxfile</span><span class="p">)</span>  <span class="c1"># 从链接下载文件并保存</span>

<span class="n">zf</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">boxfile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>  <span class="c1"># 打开下载的zip文件</span>

<span class="n">list_names</span> <span class="o">=</span> <span class="n">zf</span><span class="o">.</span><span class="n">namelist</span><span class="p">()</span>  <span class="c1"># 获取zip文件内所有文件的名称列表</span>

<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_names</span><span class="p">:</span>  <span class="c1"># 遍历文件名称列表</span>

    <span class="n">zf</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">member</span><span class="o">=</span><span class="n">item</span><span class="p">)</span>  <span class="c1"># 提取zip文件中的每个文件，使用extract而不是extractall更安全，避免绝对路径或相对路径问题</span>

<span class="n">example_file</span> <span class="o">=</span> <span class="s1">&#39;F170LP-G235M_MOS_observation-6_mod_correctedWCS_noflat_nooutlierdet_combined_s30263_&#39;</span>  <span class="c1"># 示例文件的基本名称</span>

<span class="n">s2d_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;s2d_files&#39;</span><span class="p">,</span> <span class="n">example_file</span><span class="o">+</span><span class="s1">&#39;s2d.fits&#39;</span><span class="p">)</span>  <span class="c1"># 构建s2d文件的完整路径</span>

<span class="n">x1d_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;x1d_files&#39;</span><span class="p">,</span> <span class="n">example_file</span><span class="o">+</span><span class="s1">&#39;x1d.fits&#39;</span><span class="p">)</span>  <span class="c1"># 构建x1d文件的完整路径</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">data_model</span> <span class="o">=</span> <span class="n">ImageModel</span><span class="p">(</span><span class="n">s2d_file</span><span class="p">)</span>  <span class="c1"># 创建一个ImageModel对象，加载s2d_file数据</span>

<span class="n">resampled_2d_image</span> <span class="o">=</span> <span class="n">data_model</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># 获取重采样的2D图像数据；如果有多个SCI扩展，也需要指定EXTVER</span>

<span class="n">weights_2d_image</span> <span class="o">=</span> <span class="n">data_model</span><span class="o">.</span><span class="n">wht</span>  <span class="c1"># 获取权重图像，用于后续估计每个像素的方差</span>

<span class="n">image_shape</span> <span class="o">=</span> <span class="n">resampled_2d_image</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># 获取图像的形状</span>

<span class="nb">print</span><span class="p">(</span><span class="n">image_shape</span><span class="p">)</span>  <span class="c1"># 打印图像形状；注意x和y的顺序被交换</span>
</pre></div>
</div>
</div>
</div>
<p>当我们想要查看二维光谱时，通常需要将像素在垂直方向上拉伸，以获得有用的图像。我们可以通过明确设置绘图的纵横比来实现这一点（我们会尽量保持矩形的比例）。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span> <span class="o">=</span> <span class="n">simple_norm</span><span class="p">(</span><span class="n">resampled_2d_image</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="s1">&#39;power&#39;</span><span class="p">)</span>  <span class="c1"># 使用简单归一化方法对重采样的2D图像进行归一化，采用&#39;power&#39;拉伸方式</span>

<span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 计算图像的宽高比，宽度除以高度的两倍</span>

<span class="n">fig1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c1"># 创建一个新的图形对象，保存到dummy变量中以避免Jupyter Notebook的多余输出</span>

<span class="n">img1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">resampled_2d_image</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span>  <span class="c1"># 显示重采样的2D图像，使用灰度色图和计算出的宽高比</span>
                  <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>  <span class="c1"># 应用归一化和无插值显示</span>

<span class="n">clb1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>  <span class="c1"># 添加颜色条以显示图像的颜色映射</span>
</pre></div>
</div>
</div>
</div>
<p>抱歉，您似乎没有提供任何内容需要翻译。请提供需要翻译的Markdown内容，我将很乐意为您翻译。</p>
</section>
<section id="id5">
<h2>最优提取算法<a class="headerlink" href="#id5" title="Link to this heading">#</a></h2>
<p>以下是我们将要遵循的步骤大纲：</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#Define-an-extraction-region"><span class="xref myst">在2D图像上定义提取区域</span></a></p></li>
<li><p><a class="reference internal" href="#Create-kernel-slice"><span class="xref myst">识别高信噪比（S/N）交叉色散（已分箱和叠加）切片，以用于初始核拟合</span></a></p></li>
<li><p><a class="reference internal" href="#Define-the-extraction-kernel"><span class="xref myst">定义提取核</span></a></p>
<ol class="arabic simple">
<li><p>单一或复合点扩散函数（PSF）</p></li>
<li><p>背景的多项式拟合</p></li>
</ol>
</li>
<li><p><a class="reference internal" href="#Fit-extraction-kernel"><span class="xref myst">将提取核拟合到初始切片</span></a></p></li>
<li><p><em><strong>跳过:</strong></em> <a class="reference internal" href="#Fit-geometric-distortion-(skipped)"><span class="xref myst"><em>拟合几何失真</em></span></a></p>
<ol class="arabic simple">
<li><p><em>确定用于轨迹拟合的交叉色散分箱</em></p></li>
<li><p><em>对每个分箱进行核的第一次拟合，以找到轨迹中心</em></p></li>
<li><p><em>轨迹中心的多项式拟合</em></p></li>
</ol>
</li>
<li><p><a class="reference internal" href="#Construct-final-1D-spectrum"><span class="xref myst">将复合模型（核 | 轨迹）与2D图像结合，创建输出的1D光谱</span></a></p></li>
<li><p>将输出光谱与目录光度进行比较，以进行通量校准（尚不确定如何进行）</p></li>
</ol>
<p>附录：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Appendix-A:-Batch-Processing"><span class="xref myst">附录A：批处理</span></a></p></li>
<li><p><a class="reference internal" href="#Appendix-B:-STPSF"><span class="xref myst">附录B：STPSF</span></a></p></li>
</ul>
<section id="id6">
<h3>定义提取区域<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>我们首先确定在2D重采样图像中包含我们想要提取的光谱轨迹的区域。对于只有单一源的简单情况，我们理论上可以使用整个图像。然而，我们可能仍然希望排除背景中较大的系统性波动，这可能会使拟合变得复杂，或者排除几乎没有信号的轨迹部分，这将使得拟合轨迹中心变得困难。此外，在处理背景已进行节点减法的数据时，图像中将包含负轨迹，我们也希望将其排除。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="c1"># 创建一个9x9英寸的图形，尽可能大以适应笔记本</span>

<span class="n">img2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">resampled_2d_image</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span> 
                  <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span> <span class="c1"># 显示重采样的2D图像，使用灰度色图和之前定义的归一化</span>

<span class="c1"># 创建区域框和滑块</span>

<span class="n">region_x</span> <span class="o">=</span> <span class="n">region_y</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 初始化区域框的左上角坐标为(0, 0)</span>

<span class="n">region_h</span><span class="p">,</span> <span class="n">region_w</span> <span class="o">=</span> <span class="n">image_shape</span> <span class="c1"># 获取图像的高度和宽度</span>

<span class="n">region_rectangle</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">((</span><span class="n">region_x</span><span class="p">,</span> <span class="n">region_y</span><span class="p">),</span> <span class="n">region_w</span><span class="p">,</span> <span class="n">region_h</span><span class="p">,</span> 
                             <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span> <span class="c1"># 创建一个矩形区域框，边框为蓝色虚线</span>

<span class="n">current_axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span> <span class="c1"># 获取当前坐标轴</span>

<span class="n">rect_patch</span> <span class="o">=</span> <span class="n">current_axis</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">region_rectangle</span><span class="p">)</span> <span class="c1"># 将矩形区域框添加到当前坐标轴</span>
</pre></div>
</div>
</div>
</div>
<p>我们将区域坐标设置为 <code class="docutils literal notranslate"><span class="pre">x1=51,</span> <span class="pre">y1=3,</span> <span class="pre">x2=1268,</span> <span class="pre">y2=9</span></code>，然后创建一个新数组，仅包含我们的提取区域（这样我们就不需要不断地索引原始数组）。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">1268</span>  <span class="c1"># 定义提取区域的x坐标范围</span>

<span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span>  <span class="c1"># 定义提取区域的y坐标范围</span>

<span class="c1"># 创建网格以提取指定区域的y和x坐标</span>
<span class="n">er_y</span><span class="p">,</span> <span class="n">er_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># 从重采样的2D图像中提取指定区域的像素值</span>
<span class="n">extraction_region</span> <span class="o">=</span> <span class="n">resampled_2d_image</span><span class="p">[</span><span class="n">er_y</span><span class="p">,</span> <span class="n">er_x</span><span class="p">]</span>

<span class="c1"># 从权重2D图像中提取指定区域的权重值</span>
<span class="n">weights_region</span> <span class="o">=</span> <span class="n">weights_2d_image</span><span class="p">[</span><span class="n">er_y</span><span class="p">,</span> <span class="n">er_x</span><span class="p">]</span>

<span class="c1"># 获取提取区域的形状</span>
<span class="n">er_ny</span><span class="p">,</span> <span class="n">er_nx</span> <span class="o">=</span> <span class="n">extraction_region</span><span class="o">.</span><span class="n">shape</span>

<span class="c1"># 计算长宽比</span>
<span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">er_nx</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">er_ny</span><span class="p">)</span>

<span class="c1"># 对提取区域进行简单归一化处理</span>
<span class="n">er_norm</span> <span class="o">=</span> <span class="n">simple_norm</span><span class="p">(</span><span class="n">extraction_region</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="s1">&#39;power&#39;</span><span class="p">)</span>

<span class="c1"># 创建一个新的图形</span>
<span class="n">fig3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

<span class="c1"># 显示提取区域的图像，设置颜色映射、长宽比、归一化和插值方式</span>
<span class="n">img3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">extraction_region</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span> 
                  <span class="n">norm</span><span class="o">=</span><span class="n">er_norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

<span class="c1"># 添加颜色条以显示颜色映射</span>
<span class="n">clb3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id7">
<h3>创建核切片<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>我们现在定义一个交叉色散切片（cross-dispersion slice）作为我们的提取区域，以便拟合初始提取核（extraction kernel）。作为初始猜测，我们将对位于轨迹中间的30列进行叠加（coadd）。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">slice_width</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># 定义切片的宽度</span>

<span class="n">initial_column</span> <span class="o">=</span> <span class="n">er_nx</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># 计算初始列索引，取图像宽度的一半</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kernel_slice_coadd</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">column_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    对提取区域的多个列（= width）进行叠加，</span>
<span class="sd">    以column_idx为中心。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">half_width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># 计算切片的半宽度</span>

    <span class="c1"># 生成要叠加的列索引范围，确保不超出边界</span>
    <span class="n">to_coadd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">column_idx</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">),</span> 
                         <span class="nb">min</span><span class="p">(</span><span class="n">er_nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">column_idx</span> <span class="o">+</span> <span class="n">half_width</span><span class="p">))</span>

    <span class="c1"># 返回叠加后的结果，按列求和并归一化</span>
    <span class="k">return</span> <span class="n">extraction_region</span><span class="p">[:,</span> <span class="n">to_coadd</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span>

<span class="n">slice_0</span> <span class="o">=</span> <span class="n">kernel_slice_coadd</span><span class="p">(</span><span class="n">slice_width</span><span class="p">,</span> <span class="n">initial_column</span><span class="p">)</span>  <span class="c1"># 调用函数进行切片叠加</span>
</pre></div>
</div>
</div>
</div>
<p>接下来，我们将绘制结果切片，并查看是否需要调整合成区域的宽度和中心。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建一个包含两个子图的图形，纵向排列</span>
<span class="n">fig4</span><span class="p">,</span> <span class="p">(</span><span class="n">iax4</span><span class="p">,</span> <span class="n">pax4</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

<span class="c1"># 调整子图之间的间距和图形的顶部和底部边距</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="c1"># 在第一个子图中显示提取区域的图像，使用灰度色图</span>
<span class="n">img4</span> <span class="o">=</span> <span class="n">iax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">extraction_region</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span> 
                   <span class="n">norm</span><span class="o">=</span><span class="n">er_norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

<span class="c1"># 创建切片框的函数</span>
<span class="k">def</span><span class="w"> </span><span class="nf">make_slice</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">column_idx</span><span class="p">):</span>
    <span class="n">sy</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">sw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">er_ny</span><span class="p">,</span> <span class="n">width</span>  <span class="c1"># 定义切片的起始y坐标、高度和宽度</span>
    <span class="n">sx</span> <span class="o">=</span> <span class="n">column_idx</span> <span class="o">-</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># 计算切片的起始x坐标</span>
    <span class="k">return</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span>  <span class="c1"># 返回切片的坐标和尺寸</span>

<span class="c1"># 使用切片宽度和初始列索引生成切片的坐标和尺寸</span>
<span class="o">*</span><span class="n">sxy</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">make_slice</span><span class="p">(</span><span class="n">slice_width</span><span class="p">,</span> <span class="n">initial_column</span><span class="p">)</span>

<span class="c1"># 创建一个矩形表示切片区域，设置边框颜色和样式</span>
<span class="n">slice_rectangle</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="n">sxy</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> 
                            <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>

<span class="c1"># 将切片矩形添加到第一个子图中</span>
<span class="n">iax4</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">slice_rectangle</span><span class="p">)</span>

<span class="c1"># 绘制合并切片的信号</span>
<span class="n">xd_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">er_ny</span><span class="p">)</span>  <span class="c1"># 创建x轴像素数组</span>

<span class="c1"># 在第二个子图中绘制合并切片的信号曲线</span>
<span class="n">lin4</span><span class="p">,</span> <span class="o">=</span> <span class="n">pax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">slice_0</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>

<span class="c1"># 设置第二个子图的x轴和y轴标签</span>
<span class="n">xlbl4</span> <span class="o">=</span> <span class="n">pax4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Cross-dispersion pixel&#39;</span><span class="p">)</span>  <span class="c1"># x轴标签</span>
<span class="n">ylbl4</span> <span class="o">=</span> <span class="n">pax4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Coadded signal&#39;</span><span class="p">)</span>  <span class="c1"># y轴标签</span>
</pre></div>
</div>
</div>
</div>
<p>列索引为 670，宽度为 50 对于这个文件似乎效果不错，因此我们现在可以生成用于核拟合的最终切片。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 调用函数 kernel_slice_coadd，传入参数 50 和 670，生成一个核切片</span>
<span class="n">kernel_slice</span> <span class="o">=</span> <span class="n">kernel_slice_coadd</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">670</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id8">
<h3>定义提取核<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p>现在我们将定义一个提取核（extraction kernel），该核将用于在色散方向上拟合每个像素的轨迹。这个核由两个部分组成：</p>
<ul class="simple">
<li><p>一个点扩散函数（PSF）模板（或多个PSF的组合，用于去混叠）</p></li>
<li><p>一个用于背景拟合的多项式</p></li>
</ul>
<section id="psf">
<h4>选择一个PSF模板<a class="headerlink" href="#psf" title="Link to this heading">#</a></h4>
<p>我们可以考虑多种PSF（点扩散函数）模板作为我们的内核，但全面比较超出了本笔记本的范围。我们将仅演示高斯（Gaussian）和莫法特（Moffat）轮廓。</p>
<p>需要注意两点：</p>
<ol class="arabic simple">
<li><p>这里展示的方法仅适用于真实的点源（true point source）。扩展源（extended sources）需要不同的方法论。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">STPSF</span></code>包可以直接从仪器模型构建复合PSF；然而，这一过程比使用<code class="docutils literal notranslate"><span class="pre">astropy.modeling</span></code>工具拟合1D轮廓要复杂得多，因此被放置在附录B中。</p></li>
</ol>
<p>我们首先绘制两个轮廓与核切片的关系，采用简单的归一化方法，以便暂时忽略缩放，中心位于核的最大值所在的像素。（稍后我们会进行真正的拟合，别担心！）</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">max_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">kernel_slice</span><span class="p">)</span>  <span class="c1"># 找到kernel_slice中最大值的索引</span>

<span class="n">fwhm</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># 设置全宽半高（FWHM）参数</span>

<span class="c1"># 创建Moffat型一维模型，设置幅度、gamma、中心位置和alpha参数</span>
<span class="n">moffat_profile</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Moffat1D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">fwhm</span><span class="p">,</span> <span class="n">x_0</span><span class="o">=</span><span class="n">max_pixel</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 创建高斯型一维模型，设置幅度、均值和标准差</span>
<span class="n">gauss_profile</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Gaussian1D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">max_pixel</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="n">fwhm</span><span class="p">)</span>

<span class="n">fig5</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c1"># 创建一个新的图形窗口</span>

<span class="c1"># 绘制归一化的kernel_slice</span>
<span class="n">kern5</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">kernel_slice</span> <span class="o">/</span> <span class="n">kernel_slice</span><span class="p">[</span><span class="n">max_pixel</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Kernel Slice&#39;</span><span class="p">)</span>

<span class="c1"># 绘制Moffat型曲线</span>
<span class="n">moff5</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">moffat_profile</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Moffat Profile&#39;</span><span class="p">)</span>

<span class="c1"># 绘制高斯型曲线</span>
<span class="n">gaus5</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">gauss_profile</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Gaussian Profile&#39;</span><span class="p">)</span>

<span class="n">lgd5</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>  <span class="c1"># 添加图例</span>
</pre></div>
</div>
</div>
</div>
<p>高斯轮廓看起来是一个更好的近似，因此我们将使用这个轮廓来处理该光谱。在下面的单元格中，我们可以使用 <a class="reference external" href="https://docs.astropy.org/en/stable/modeling/compound-models.html">模型操作</a> 添加更多的点扩散函数（PSF）模板；这留给读者作为练习。</p>
<p>我们需要对幅度进行去归一化，因此我们将其设置为切片的最大像素值。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psf_template</span> <span class="o">=</span> <span class="n">gauss_profile</span>  <span class="c1"># 将高斯轮廓赋值给psf_template</span>

<span class="n">psf_template</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">kernel_slice</span><span class="p">[</span><span class="n">max_pixel</span><span class="p">]</span>  <span class="c1"># 设置psf_template的幅度为kernel_slice中最大像素的值</span>

<span class="nb">print</span><span class="p">(</span><span class="n">psf_template</span><span class="p">)</span>  <span class="c1"># 打印psf_template以查看其内容</span>

<span class="c1"># 如果需要对多个源进行解混合，可以在这里添加更多的PSF模板：</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id9">
<h4>多项式背景<a class="headerlink" href="#id9" title="Link to this heading">#</a></h4>
<p>我们将使用多项式来拟合背景。建议进行一些实验，以找到最适合数据的多项式阶数；在这个例子中，我们将使用二次多项式（2nd-degree polynomial）。</p>
<p>对于经过点位减法（nod-subtracted）处理的数据，提取区域内可能没有足够的像素来准确拟合残差。在这种情况下，可以使用零阶多项式（0th-order polynomial）或 <code class="docutils literal notranslate"><span class="pre">Const1D</span></code> 模型来表示背景；如果希望完全避免拟合背景，可以将参数设置为 <code class="docutils literal notranslate"><span class="pre">fixed</span> <span class="pre">=</span> <span class="pre">True</span></code>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建一个二次多项式模型</span>
<span class="n">background_poly</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Polynomial1D</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># 打印多项式模型的详细信息</span>
<span class="nb">print</span><span class="p">(</span><span class="n">background_poly</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>最后一步是将点扩散函数（PSF）和背景结合起来，以创建我们的复合模型。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义提取核，包含点扩散函数模板和背景多项式</span>
<span class="n">extraction_kernel</span> <span class="o">=</span> <span class="n">psf_template</span> <span class="o">+</span> <span class="n">background_poly</span>

<span class="c1"># 打印提取核的内容</span>
<span class="nb">print</span><span class="p">(</span><span class="n">extraction_kernel</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="id10">
<h3>拟合提取核<a class="headerlink" href="#id10" title="Link to this heading">#</a></h3>
<p>现在我们已经有了一个提取核（extraction kernel），我们希望将其拟合到我们的核切片（kernel slice），以便在下一步中拥有最佳的工具来拟合轨迹中心（trace centers）。我们还绘制了拟合组件（fit components）以及拟合与核切片的对比图（fit vs the kernel slice），作为视觉检查；如果结果不可接受，我们可以返回到前一部分，调整参数，然后再试一次。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fitter</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">LevMarLSQFitter</span><span class="p">()</span>  <span class="c1"># 创建一个Levenberg-Marquardt最小二乘拟合器</span>

<span class="n">fit_extraction_kernel</span> <span class="o">=</span> <span class="n">fitter</span><span class="p">(</span><span class="n">extraction_kernel</span><span class="p">,</span> <span class="n">xd_pixels</span><span class="p">,</span> <span class="n">kernel_slice</span><span class="p">)</span>  <span class="c1"># 拟合提取核</span>

<span class="nb">print</span><span class="p">(</span><span class="n">fit_extraction_kernel</span><span class="p">)</span>  <span class="c1"># 打印拟合结果</span>

<span class="n">fit_line</span> <span class="o">=</span> <span class="n">fit_extraction_kernel</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">)</span>  <span class="c1"># 计算拟合线</span>

<span class="n">fig6</span><span class="p">,</span> <span class="p">(</span><span class="n">fax6</span><span class="p">,</span> <span class="n">fln6</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>  <span class="c1"># 创建一个包含两个子图的图形</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>  <span class="c1"># 调整子图之间的间距和图形的边距</span>

<span class="n">psf6</span> <span class="o">=</span> <span class="n">fax6</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">fit_extraction_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">xd_pixels</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;PSF&quot;</span><span class="p">)</span>  <span class="c1"># 绘制点扩散函数（PSF）</span>

<span class="n">poly6</span> <span class="o">=</span> <span class="n">fax6</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">fit_extraction_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">xd_pixels</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Background&quot;</span><span class="p">)</span>  <span class="c1"># 绘制背景</span>

<span class="n">sum6</span> <span class="o">=</span> <span class="n">fax6</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">fit_line</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Composite Kernel&quot;</span><span class="p">)</span>  <span class="c1"># 绘制复合核</span>

<span class="n">lgd6a</span> <span class="o">=</span> <span class="n">fax6</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>  <span class="c1"># 添加图例到第一个子图</span>

<span class="n">lin6</span> <span class="o">=</span> <span class="n">fln6</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">kernel_slice</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Kernel Slice&#39;</span><span class="p">)</span>  <span class="c1"># 绘制核切片</span>

<span class="n">fit6</span> <span class="o">=</span> <span class="n">fln6</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">fit_line</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Extraction Kernel&#39;</span><span class="p">)</span>  <span class="c1"># 绘制提取核的拟合结果</span>

<span class="n">lgd6b</span> <span class="o">=</span> <span class="n">fln6</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>  <span class="c1"># 添加图例到第二个子图</span>
</pre></div>
</div>
</div>
</div>
<section id="fwhm">
<h4>波长变化的全宽半最大值 (FWHM)（已跳过）<a class="headerlink" href="#fwhm" title="Link to this heading">#</a></h4>
<p>NIRSpec 的点扩散函数（PSF）宽度会随波长变化，因此对于科学数据，沿光谱轨迹的多个位置进行拟合可能是有益的。下面是该过程的演示；然而，请注意，对于这个示例数据集，未经过优化的重采样和合并抖动输入光谱引入了宽度变化伪影，因此我们实际上不会使用此步骤的结果进行提取。</p>
<p>如果我们希望考虑变化的全宽半最大值（FWHM），我们可以在色散方向上对二维光谱进行分箱，并对每个箱进行拟合。我们上面定义的核可以作为我们的初始估计，这在光谱的非常微弱区域中可能会很有帮助，因为<code class="docutils literal notranslate"><span class="pre">astropy.modeling</span></code>的拟合例程对初始估计非常敏感。</p>
<p>（在计算并绘制了分箱的核FWHM后，下一步将是找到合适的模型，并将FWHM作为箱中心的函数进行拟合。拟合模型将被包含在下面的最终一维提取中。）</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_bin</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># 设置要分的bin的数量</span>

<span class="n">bin_width</span> <span class="o">=</span> <span class="n">er_nx</span> <span class="o">//</span> <span class="n">n_bin</span>  <span class="c1"># 计算每个bin的宽度</span>

<span class="c1"># 计算每个bin的中心位置</span>
<span class="n">bin_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">er_nx</span><span class="p">,</span> <span class="n">bin_width</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="n">bin_width</span> <span class="o">//</span> <span class="mi">2</span>

<span class="c1"># 将提取区域中的光谱数据按bin宽度进行求和，形成binned_spectrum</span>
<span class="n">binned_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">extraction_region</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">bin_width</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> 
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">er_nx</span><span class="p">,</span> <span class="n">bin_width</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

<span class="c1"># 初始化一个与bin_centers相同形状的数组，用于存储每个bin的FWHM</span>
<span class="n">bin_fwhms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bin_centers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="c1"># 遍历每个bin中心，进行拟合以获取FWHM</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bin_centers</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
    <span class="n">bin_fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="p">(</span><span class="n">fit_extraction_kernel</span><span class="p">,</span> <span class="n">xd_pixels</span><span class="p">,</span> <span class="n">binned_spectrum</span><span class="p">[:,</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># 拟合当前bin的光谱</span>
    <span class="n">bin_fwhms</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_fit</span><span class="o">.</span><span class="n">stddev_0</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># 存储拟合得到的FWHM值</span>

<span class="c1"># 获取binned_spectrum的形状</span>
<span class="n">bin_ny</span><span class="p">,</span> <span class="n">bin_nx</span> <span class="o">=</span> <span class="n">binned_spectrum</span><span class="o">.</span><span class="n">shape</span>

<span class="c1"># 计算图像的宽高比</span>
<span class="n">bin_ar</span> <span class="o">=</span> <span class="n">bin_nx</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">bin_ny</span><span class="p">)</span>

<span class="c1"># 创建一个包含两个子图的图形</span>
<span class="n">fig_fwhm</span><span class="p">,</span> <span class="n">ax_fwhm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>  <span class="c1"># 调整子图之间的间距</span>

<span class="c1"># 在第一个子图中显示binned_spectrum的图像</span>
<span class="n">fwhm_img</span> <span class="o">=</span> <span class="n">ax_fwhm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binned_spectrum</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">bin_ar</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                             <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>

<span class="c1"># 在第二个子图中绘制bin中心与FWHM的关系</span>
<span class="n">fwhm_plot</span> <span class="o">=</span> <span class="n">ax_fwhm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bin_centers</span><span class="p">,</span> <span class="n">bin_fwhms</span><span class="p">)</span>

<span class="c1"># 设置第二个子图的x轴标签</span>
<span class="n">xlbl_fwhm</span> <span class="o">=</span> <span class="n">ax_fwhm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Bin center (px)&quot;</span><span class="p">)</span>

<span class="c1"># 设置第二个子图的y轴标签</span>
<span class="n">ylbl_fwhm</span> <span class="o">=</span> <span class="n">ax_fwhm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;FWHM (arcsec)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="id11">
<h3>拟合几何畸变 <em>(跳过)</em><a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>管道 <code class="docutils literal notranslate"><span class="pre">resample</span></code> 步骤将所有输入的二维光谱滴水（drizzle）到一个矩形网格上，因此我们最优提取过程中的这一特定步骤通常不是必需的。这里简要讨论该过程，以作为提取未矩形光谱（后缀为 <code class="docutils literal notranslate"><span class="pre">_cal.fits</span></code>）的指南，其中光谱的轨迹可能具有显著的曲率，并且轨迹的色散并不与列对齐。</p>
<section id="id12">
<h4>定义轨迹拟合的区间<a class="headerlink" href="#id12" title="Link to this heading">#</a></h4>
<p>根据2D重采样光谱的噪声水平，定义色散方向上的区间可能是有益的。这些区间可以是均匀或不均匀分布的，一旦定义完成，就可以对每个区间中的列进行合并（可能使用<code class="docutils literal notranslate"><span class="pre">s2d</span></code>文件中的<code class="docutils literal notranslate"><span class="pre">WHT</span></code>扩展），并创建一个区间中心位置的数组。</p>
<p>如果2D光谱的信噪比（S/N）很高，这一步可能就不必要了，每个交叉色散列可以在下一步中单独拟合。</p>
</section>
<section id="id13">
<h4>使用修改后的提取核拟合每个箱体<a class="headerlink" href="#id13" title="Link to this heading">#</a></h4>
<p>我们希望用我们的提取核拟合每个定义的箱体，但我们不希望其他伪影或噪声干扰轨迹。因此，我们复制提取核，然后将除轮廓中心（上面示例中的 <code class="docutils literal notranslate"><span class="pre">mean_0</span></code>）以外的每个参数设置为 <code class="docutils literal notranslate"><span class="pre">fixed</span> <span class="pre">=</span> <span class="pre">True</span></code>。从轨迹的一端开始，遍历每个箱体，使用提取核拟合切片，并将结果轨迹中心存储在一个数组中。</p>
</section>
<section id="id14">
<h4>使用一维多项式拟合轨迹中心<a class="headerlink" href="#id14" title="Link to this heading">#</a></h4>
<p>这一步很简单：创建一个 <code class="docutils literal notranslate"><span class="pre">Polynomial1D</span></code> 模型，然后将其拟合到上一步骤得到的轨迹中心。</p>
<p>由于我们不会进行拟合，而是创建一个占位符轨迹中心模型：一个零阶多项式。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trace_center_model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Polynomial1D</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 我们使用常数，因为光谱已经被校正</span>
<span class="n">trace_center_model</span><span class="o">.</span><span class="n">c0</span> <span class="o">=</span> <span class="n">fit_extraction_kernel</span><span class="o">.</span><span class="n">mean_0</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># 使用PSF轮廓中心的参数</span>

<span class="nb">print</span><span class="p">(</span><span class="n">trace_center_model</span><span class="p">)</span>  <span class="c1"># 打印模型信息</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="d">
<h3>构建最终的1D光谱<a class="headerlink" href="#d" title="Link to this heading">#</a></h3>
<p>我们计算最终的1D光谱作为2D光谱在交叉色散方向上的加权和，使用我们基于轨迹中心的复合模型（提取核）作为权重。我们还需要纳入每个像素的方差，这将通过重采样步骤输出的<code class="docutils literal notranslate"><span class="pre">WHT</span></code>扩展来估计。</p>
<section id="id15">
<h4>创建方差图像<a class="headerlink" href="#id15" title="Link to this heading">#</a></h4>
<p>Horne 的算法需要每个像素的方差。目前，误差并未在重采样步骤中传播；然而，根据 <a class="reference external" href="https://www.stsci.edu/files/live/sites/www/files/home/scientific-community/software/drizzlepac/_documents/drizzlepac-handbook.pdf">DrizzlePac 手册</a>，我们可以通过雨滴权重图像来估计方差：<span class="math notranslate nohighlight">\( Var \approx 1 / (W \times s^4) \)</span>，其中 <span class="math notranslate nohighlight">\(s\)</span> 是像素尺度。目前，NIRSpec 的雨滴参数设置为 <code class="docutils literal notranslate"><span class="pre">PIXFRAC</span> <span class="pre">=</span> <span class="pre">1.0</span></code>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># 调整此值以应对NIRSpec PIXFRAC的变化</span>

<span class="c1"># 我们希望在下一步中排除任何权重为0的像素</span>
<span class="c1"># 因此，我们将使用掩码数组操作。</span>

<span class="n">bad_pixels</span> <span class="o">=</span> <span class="n">weights_region</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># 标记权重为0的像素</span>

<span class="n">masked_wht</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights_region</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">bad_pixels</span><span class="p">)</span>  <span class="c1"># 创建掩码数组，掩盖坏像素</span>

<span class="n">variance_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">weights_region</span> <span class="o">*</span> <span class="n">scale</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 计算方差图像，使用掩码数组</span>
</pre></div>
</div>
</div>
</div>
<p>我们可以显示方差图像，以查看提取区域中是否有任何区域不会包含在光谱中（如下图所示，红色区域表示）。对于这个特定的光谱示例，每个像素都有非零权重。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">copy</span>  <span class="c1"># 从copy模块导入copy函数</span>

<span class="n">fig_var</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c1"># 创建一个新的图形窗口</span>

<span class="n">palette</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>  <span class="c1"># 复制灰度调色板</span>

<span class="n">palette</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>  <span class="c1"># 设置无效值的颜色为红色，透明度为0.7</span>

<span class="n">var_norm</span> <span class="o">=</span> <span class="n">simple_norm</span><span class="p">(</span><span class="n">variance_image</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">0.006</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># 对方差图像进行归一化处理，使用对数伸缩</span>

<span class="n">img_var</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">variance_image</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">var_norm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>  <span class="c1"># 显示方差图像，设置插值方式、纵横比、归一化和调色板</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="id16">
<h2>生成一维光谱<a class="headerlink" href="#id16" title="Link to this heading">#</a></h2>
<p>现在，我们最终计算我们的1D光谱，通过对交叉色散列进行求和：</p>
<div class="math notranslate nohighlight">
\[S_x = \frac{1}{G_x}\sum_{y} \frac{I_{xy}\cdot K_y(x)}{V_{xy}}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(I\)</span> 是二维重采样图像中的像素值，<span class="math notranslate nohighlight">\(K\)</span> 是设置为列的轨迹中心的提取核，<span class="math notranslate nohighlight">\(V\)</span> 是方差图像中的像素值，而 <span class="math notranslate nohighlight">\(G\)</span> 是由以下公式给出的核归一化：</p>
<div class="math notranslate nohighlight">
\[G_x = \sum_y \frac{K_y^2(x)}{V_{xy}}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">er_nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># 初始化我们的光谱，填充为零</span>

<span class="n">column_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">er_nx</span><span class="p">)</span> <span class="c1"># 创建一个包含列像素的数组</span>

<span class="n">trace_centers</span> <span class="o">=</span> <span class="n">trace_center_model</span><span class="p">(</span><span class="n">column_pixels</span><span class="p">)</span> <span class="c1"># 计算我们的轨迹中心数组</span>

<span class="c1"># 遍历每一列</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">column_pixels</span><span class="p">:</span>

    <span class="c1"># 为这一列创建内核，使用拟合的轨迹中心</span>

    <span class="n">kernel_column</span> <span class="o">=</span> <span class="n">fit_extraction_kernel</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># 复制提取内核</span>

    <span class="n">kernel_column</span><span class="o">.</span><span class="n">mean_0</span> <span class="o">=</span> <span class="n">trace_centers</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="c1"># 设置内核的均值为轨迹中心</span>

    <span class="c1"># kernel_column.stddev_0 = fwhm_fit(x) # 如果考虑变化的FWHM，取消注释这一行。</span>

    <span class="n">kernel_values</span> <span class="o">=</span> <span class="n">kernel_column</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">)</span> <span class="c1"># 计算当前列的内核值</span>

    

    <span class="c1"># 根据Horne1986方程5进行单位归一化，P_x = P/sum(P_x)。 </span>

    <span class="n">kernel_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">kernel_values</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="c1"># 遮蔽无效值</span>

    <span class="n">kernel_values</span> <span class="o">=</span> <span class="n">kernel_values</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_values</span><span class="p">)</span> <span class="c1"># 归一化内核值</span>

    

    <span class="c1"># 隔离光谱和方差图像中相关的列</span>

    <span class="n">variance_column</span> <span class="o">=</span> <span class="n">variance_image</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span> <span class="c1"># 记住，numpy数组是行，列的顺序</span>

    <span class="n">image_pixels</span> <span class="o">=</span> <span class="n">extraction_region</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span> <span class="c1"># 获取提取区域的像素值</span>

    

    <span class="c1"># 计算内核归一化</span>

    <span class="n">g_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_values</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">variance_column</span><span class="p">)</span> <span class="c1"># 计算归一化因子</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">g_x</span><span class="p">):</span> <span class="c1"># 如果这一列无效，则跳过</span>

        <span class="k">continue</span>

    

    <span class="c1"># 现在对加权列进行求和</span>

    <span class="n">weighted_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">image_pixels</span> <span class="o">*</span> <span class="n">kernel_values</span><span class="p">,</span> <span class="n">variance_column</span><span class="p">)</span> <span class="c1"># 计算加权列</span>

    <span class="n">spectrum</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weighted_column</span><span class="p">)</span> <span class="o">/</span> <span class="n">g_x</span> <span class="c1"># 将加权列的和除以归一化因子，得到光谱值</span>
</pre></div>
</div>
</div>
</div>
<p>我们需要一个波长数组来显示光谱，这可以通过从数据模型的元数据中存储的WCS对象创建。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">wcs</span> <span class="o">=</span> <span class="n">data_model</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">wcs</span>  <span class="c1"># 获取数据模型中的WCS（世界坐标系统）信息</span>

<span class="nb">print</span><span class="p">(</span><span class="n">wcs</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>  <span class="c1"># 打印WCS对象的字符串表示</span>

<span class="n">alpha_C</span><span class="p">,</span> <span class="n">delta_C</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">wcs</span><span class="p">(</span><span class="n">er_x</span><span class="p">,</span> <span class="n">er_y</span><span class="p">)</span>  <span class="c1"># 使用WCS将像素坐标（er_x, er_y）转换为天球坐标（alpha_C, delta_C）和波长（y）</span>

<span class="n">wavelength</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 提取波长信息，y数组的第一个元素</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig7</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c1"># 创建一个新的图形窗口</span>

<span class="n">spec7</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)</span>  <span class="c1"># 绘制波长与光谱的关系图</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 将提取的光谱写入文件</span>

<span class="c1"># 这部分留给读者练习</span>

<span class="c1"># 假设我们有一个光谱数据的数组和文件名</span>
<span class="n">spectrum_data</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>  <span class="c1"># 光谱数据数组</span>
<span class="n">output_filename</span> <span class="o">=</span> <span class="s1">&#39;spectrum.txt&#39;</span>  <span class="c1"># 输出文件名</span>

<span class="c1"># 打开文件以写入数据</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>  <span class="c1"># 以写入模式打开文件</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">spectrum_data</span><span class="p">:</span>  <span class="c1"># 遍历光谱数据中的每个值</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># 将每个值写入文件，并换行</span>

<span class="n">在这个代码中</span><span class="err">，</span><span class="n">我们假设有一个光谱数据的数组</span><span class="err">`</span><span class="n">spectrum_data</span><span class="err">`</span><span class="n">和一个输出文件名</span><span class="err">`</span><span class="n">output_filename</span><span class="err">`。</span><span class="n">通过打开文件并遍历光谱数据</span><span class="err">，</span><span class="n">我们将每个值写入文件中</span><span class="err">。</span>
</pre></div>
</div>
</div>
</div>
<p>我们还想将我们优化提取的光谱与 <code class="docutils literal notranslate"><span class="pre">x1d</span></code> 管道产品进行比较。我们将对光谱进行归一化，以便能够在同一坐标轴上绘制它们。</p>
<p>（请注意，<code class="docutils literal notranslate"><span class="pre">x1d</span></code> 光谱包含来自背景减除步骤的负值，这通常会导致负的通量计算。在与我们优化提取的版本进行比较时，我们需要对此进行修正。）</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x1d_model</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">x1d_file</span><span class="p">)</span>  <span class="c1"># 打开指定的x1d文件，返回一个FITS模型对象</span>

<span class="c1"># For a file with multiple spectra, the index to .spec is EXTVAR  # 对于包含多个光谱的文件，.spec的索引为EXTVAR</span>

<span class="n">tmp</span> <span class="o">=</span> <span class="n">x1d_model</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># 获取FITS模型中第二个扩展的数据</span>

<span class="n">x1d_wave</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;WAVELENGTH&#39;</span><span class="p">]</span>  <span class="c1"># 提取波长数据</span>

<span class="n">x1d_flux</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span>  <span class="c1"># 提取光谱数据</span>

<span class="k">if</span> <span class="n">x1d_flux</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 如果光谱数据的总和小于等于0</span>
    <span class="n">x1d_flux</span> <span class="o">=</span> <span class="o">-</span><span class="n">x1d_flux</span>  <span class="c1"># 将光谱数据取反</span>

<span class="n">fig8</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c1"># 创建一个新的图形窗口</span>

<span class="n">x1d8</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1d_wave</span><span class="p">,</span> <span class="n">x1d_flux</span> <span class="o">/</span> <span class="n">x1d_flux</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Pipeline&quot;</span><span class="p">)</span>  <span class="c1"># 绘制归一化后的光谱数据，标签为&quot;Pipeline&quot;</span>

<span class="n">opt8</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">spectrum</span> <span class="o">/</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Optimal&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>  <span class="c1"># 绘制优化光谱数据，标签为&quot;Optimal&quot;，透明度为0.7</span>

<span class="n">lgd8</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>  <span class="c1"># 显示图例</span>
</pre></div>
</div>
</div>
</div>
<p>看起来您没有提供任何Markdown内容。请提供需要翻译的文本，我将帮助您进行翻译并保持格式。</p>
</section>
<section id="a">
<h2>附录 A：批处理<a class="headerlink" href="#a" title="Link to this heading">#</a></h2>
<p>当需要对大量光谱进行最佳提取时，逐步按照上述过程处理每个光谱可能不够实际。在这种情况下，我们可以最初对一两个光谱使用这些交互式方法，以便决定一些提取参数（例如，使用什么点扩散函数（PSF）模板轮廓，或者用什么阶数的多项式来拟合背景），然后使用这些参数以非交互方式处理所有光谱。之后，我们可以检查每个提取光谱的输出，并重新审视任何需要更个性化处理的光谱。</p>
<p>我们可以通过为上述每个步骤定义函数，以及一个单一的主函数来迭代单个目录中的所有光谱，从而非交互式地提取大量光谱。</p>
<section id="id17">
<h3>定义提取区域<a class="headerlink" href="#id17" title="Link to this heading">#</a></h3>
<p>这个步骤无法以非交互方式执行，因此我们在这里跳过。不过，对于真实数据集，有两种好的方法（和一种不好的方法）来处理这个问题：</p>
<ol class="arabic simple">
<li><p>在批处理之前为每个二维光谱定义一个提取区域。您可以将区域边界框保存到一个 Python 字典中（或者将它们写入文件，然后在迭代时读取）。</p></li>
<li><p>直观地检查二维光谱，仅对那些不需要定义特定提取区域（即小于完整二维光谱）的光谱进行批处理。其余光谱可以单独提取。</p></li>
<li><p>跳过此步骤，并假设任何需要定义特定提取区域的光谱都需要单独重新处理。虽然不推荐这种方法，但我们将在这里使用它。</p></li>
</ol>
</section>
<section id="id18">
<h3>创建核切片<a class="headerlink" href="#id18" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">batch_kernel_slice</span><span class="p">(</span><span class="n">extraction_region</span><span class="p">,</span> <span class="n">slice_width</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">column_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    在提取区域 `extraction_region` 中创建一个切片， </span>
<span class="sd">    该切片在交叉色散方向上，以 `column_idx` 为中心， </span>
<span class="sd">    宽度为 `slice_width` 像素。如果未给定 `column_idx`， </span>
<span class="sd">    则使用总信号最大的列。</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 如果没有提供列索引，则找到信号总和最大的列索引</span>
    <span class="k">if</span> <span class="n">column_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">column_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">extraction_region</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># 获取提取区域的形状</span>
    <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">extraction_region</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">half_width</span> <span class="o">=</span> <span class="n">slice_width</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># 计算切片的一半宽度</span>

    <span class="c1"># 确保切片不会超出提取区域的边界</span>
    <span class="n">to_coadd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">column_idx</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">),</span> 
                         <span class="nb">min</span><span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">column_idx</span> <span class="o">+</span> <span class="n">half_width</span><span class="p">))</span>

    <span class="c1"># 返回切片在交叉方向上的平均值</span>
    <span class="k">return</span> <span class="n">extraction_region</span><span class="p">[:,</span> <span class="n">to_coadd</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">slice_width</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id19">
<h3>创建并拟合提取核<a class="headerlink" href="#id19" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">batch_fit_extraction_kernel</span><span class="p">(</span><span class="n">xd_slice</span><span class="p">,</span> <span class="n">psf_profile</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">Gaussian1D</span><span class="p">,</span> 

                                <span class="n">height_param_name</span><span class="o">=</span><span class="s1">&#39;amplitude&#39;</span><span class="p">,</span> <span class="n">height_param_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>

                                <span class="n">width_param_name</span><span class="o">=</span><span class="s1">&#39;stddev&#39;</span><span class="p">,</span> <span class="n">width_param_value</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>

                                <span class="n">center_param_name</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">center_param_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>

                                <span class="n">other_psf_args</span><span class="o">=</span><span class="p">[],</span> <span class="n">other_psf_kw</span><span class="o">=</span><span class="p">{},</span>

                                <span class="n">bg_model</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">Polynomial1D</span><span class="p">,</span>

                                <span class="n">bg_args</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bg_kw</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    初始化一个复合提取核，然后将其拟合到</span>
<span class="sd">    一维数组 `xd_slice`，该数组通常是通过</span>
<span class="sd">    上面定义的 `kernel_slice` 函数生成的。</span>

<span class="sd">    为了允许具有不同参数名称的 PSF 模板模型，</span>
<span class="sd">    我们使用 `height_param_*`、`width_param_*` 和</span>
<span class="sd">    `center_param_*` 关键字参数。我们将任何其他</span>
<span class="sd">    位置或关键字参数收集到 PSF 模型中，</span>
<span class="sd">    存储在 `other_psf_*` 中。如果高度或中心值为 `None`，</span>
<span class="sd">    则将从数据中计算它们。</span>

<span class="sd">    同样，任何希望传递给背景拟合模型（默认为 `Polynomial1D`）的</span>
<span class="sd">    位置或关键字参数都可以通过 `bg_args` 和 `bg_kw` 接受。</span>

<span class="sd">    请注意，此函数无法处理涉及多个 PSF 进行解混合的情况。</span>
<span class="sd">    建议单独处理此类光谱，使用上述交互程序。</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xd_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xd_slice</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># 创建一个像素索引数组</span>

    <span class="k">if</span> <span class="n">center_param_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 如果中心参数值为 None</span>
        <span class="n">center_param_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">xd_slice</span><span class="p">)</span>  <span class="c1"># 计算最大值的索引作为中心</span>

    <span class="k">if</span> <span class="n">height_param_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 如果高度参数值为 None</span>
        <span class="c1"># 如果通过 center_param_value 传递了非整数值，</span>
        <span class="c1"># 我们需要进行插值。</span>
        <span class="n">slice_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">xd_slice</span><span class="p">)</span>  <span class="c1"># 创建插值函数</span>
        <span class="n">height_param_value</span> <span class="o">=</span> <span class="n">slice_interp</span><span class="p">(</span><span class="n">center_param_value</span><span class="p">)</span>  <span class="c1"># 计算高度值</span>

    <span class="c1"># 创建 PSF 和背景模型</span>
    <span class="n">psf_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">height_param_name</span><span class="p">,</span> <span class="n">height_param_value</span><span class="p">),</span>  <span class="c1"># 设置高度参数</span>
                   <span class="p">(</span><span class="n">width_param_name</span><span class="p">,</span> <span class="n">width_param_value</span><span class="p">),</span>  <span class="c1"># 设置宽度参数</span>
                   <span class="p">(</span><span class="n">center_param_name</span><span class="p">,</span> <span class="n">center_param_value</span><span class="p">)])</span>  <span class="c1"># 设置中心参数</span>
    <span class="n">psf_kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other_psf_kw</span><span class="p">)</span>  <span class="c1"># 更新其他 PSF 参数</span>
    <span class="n">psf</span> <span class="o">=</span> <span class="n">psf_profile</span><span class="p">(</span><span class="o">*</span><span class="n">other_psf_args</span><span class="p">,</span> <span class="o">**</span><span class="n">psf_kw</span><span class="p">)</span>  <span class="c1"># 创建 PSF 实例</span>

    <span class="n">bg</span> <span class="o">=</span> <span class="n">bg_model</span><span class="p">(</span><span class="o">*</span><span class="n">bg_args</span><span class="p">,</span> <span class="o">**</span><span class="n">bg_kw</span><span class="p">)</span>  <span class="c1"># 创建背景模型实例</span>

    <span class="n">composite_kernel</span> <span class="o">=</span> <span class="n">psf</span> <span class="o">+</span> <span class="n">bg</span>  <span class="c1"># 组合 PSF 和背景模型</span>

    <span class="n">fitter</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">LevMarLSQFitter</span><span class="p">()</span>  <span class="c1"># 创建拟合器实例</span>
    <span class="k">return</span> <span class="n">fitter</span><span class="p">(</span><span class="n">composite_kernel</span><span class="p">,</span> <span class="n">xd_pixels</span><span class="p">,</span> <span class="n">xd_slice</span><span class="p">)</span>  <span class="c1"># 返回拟合结果</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id20">
<h3>考虑变化的全宽半最大值（FWHM）<a class="headerlink" href="#id20" title="Link to this heading">#</a></h3>
<p>根据<a class="reference internal" href="#Wavelength-varying-FWHM"><span class="xref myst">这里</span></a>所示的过程，这部分留给用户自行练习。请注意，如果需要，下面的 <code class="docutils literal notranslate"><span class="pre">batch_extract_spectrum</span></code> 和 <code class="docutils literal notranslate"><span class="pre">batch_optimal_extraction</span></code> 也需要进行修改，以纳入此功能。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">batch_vary_fwhm</span><span class="p">(</span><span class="n">extraction_region</span><span class="p">,</span> <span class="n">kernel</span><span class="p">):</span>
    <span class="c1"># 定义一个函数，拟合波长变化的全宽半最大值（FWHM）</span>

    <span class="k">pass</span>  <span class="c1"># 实现该函数的具体逻辑</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id21">
<h3>拟合轨迹中心<a class="headerlink" href="#id21" title="Link to this heading">#</a></h3>
<p>如果需要，请将此替换为一个实际的执行拟合的函数。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">batch_fit_trace_centers</span><span class="p">(</span><span class="n">extraction_region</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span>
                            <span class="n">trace_model</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">Polynomial1D</span><span class="p">,</span>  <span class="c1"># 使用多项式模型进行轨迹拟合</span>
                            <span class="n">trace_args</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trace_kw</span><span class="o">=</span><span class="p">{}):</span>  <span class="c1"># 模型参数和关键字参数</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    使用模型拟合轨迹的几何失真。</span>
<span class="sd">    目前这是一个占位符函数，因为几何失真通常在`resample`步骤中被移除。</span>
<span class="sd">    但是，如果需要此功能，请使用此函数签名以保持与本附录其余部分的兼容性。</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">trace_centers</span> <span class="o">=</span> <span class="n">trace_model</span><span class="p">(</span><span class="o">*</span><span class="n">trace_args</span><span class="p">,</span> <span class="o">**</span><span class="n">trace_kw</span><span class="p">)</span>  <span class="c1"># 创建轨迹中心模型</span>
    <span class="n">trace_centers</span><span class="o">.</span><span class="n">c0</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">mean_0</span>  <span class="c1"># 设置轨迹中心的初始值为核的均值</span>

    <span class="k">return</span> <span class="n">trace_centers</span>  <span class="c1"># 返回拟合后的轨迹中心</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id22">
<h3>生成一维光谱<a class="headerlink" href="#id22" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">batch_extract_spectrum</span><span class="p">(</span><span class="n">extraction_region</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> 

                           <span class="n">weights_image</span><span class="p">,</span> 

                           <span class="n">trace_center_param</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>

                           <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    从提取区域优化提取1D光谱。</span>

<span class="sd">    </span>

<span class="sd">    从`weights_image`（应与`extraction_region`具有相同的维度）创建方差图像。</span>

<span class="sd">    然后，对于光谱的每一列，我们根据上述定义的方程求和光圈，</span>

<span class="sd">    遮蔽权重为零的像素。 </span>

<span class="sd">    </span>

<span class="sd">    注意，与交互式逐步方法不同，这里我们将进行向量化以提高速度。</span>

<span class="sd">    这需要使用模型集来处理核，但这是允许的，因为</span>

<span class="sd">    我们不需要拟合任何东西。</span>

<span class="sd">    </span>

<span class="sd">    `trace_center_param`是定义轨迹中心的参数名称，</span>

<span class="sd">    *不带模型编号下标*（因为我们将单独处理组件）。</span>

<span class="sd">    </span>

<span class="sd">    `scale`是输入像素与输出像素的大小比率，</span>

<span class="sd">    在滴水时等同于`resample`步骤中的滴水参数中的PIXFRAC。</span>

<span class="sd">    &quot;&quot;&quot;</span>

    

    <span class="n">bad_pixels</span> <span class="o">=</span> <span class="n">weights_image</span> <span class="o">==</span> <span class="mf">0.</span>  <span class="c1"># 标记权重为零的坏像素</span>
    <span class="n">masked_wht</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights_image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">bad_pixels</span><span class="p">)</span>  <span class="c1"># 创建带掩码的权重数组</span>
    <span class="n">variance_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">masked_wht</span> <span class="o">*</span> <span class="n">scale</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 计算方差图像</span>
    
    <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">extraction_region</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># 获取提取区域的形状</span>
    <span class="n">trace_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>  <span class="c1"># 创建轨迹像素数组</span>
    <span class="n">xd_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>  <span class="c1"># 创建y方向像素数组</span>
    <span class="n">trace_centers</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">trace_pixels</span><span class="p">)</span>  <span class="c1"># 计算轨迹中心数组</span>
    
    <span class="c1"># 创建用于向量化的核图像，这需要一些技巧...</span>
    <span class="c1"># ******************************************************************</span>
    <span class="c1"># * 重要提示:                                                     *</span>
    <span class="c1"># * ----------                                                     *</span>
    <span class="c1"># * 注意，由于模型集的实现方式，修改现有模型实例以使用它们是不可行的。  *</span>
    <span class="c1"># * 相反，我们将创建一个新的核实例，使用原始核的拟合参数。                           *</span>
    <span class="c1"># *                                                                *</span>
    <span class="c1"># * 警告：这假设PSF是第一个元素，背景是第二个。如果您在创建复合核时更改了这一点，*</span>
    <span class="c1"># * 请确保相应地更新此部分，否则将无法正常工作！                                *</span>
    <span class="c1"># ******************************************************************</span>
    
    <span class="n">psf0</span><span class="p">,</span> <span class="n">bg0</span> <span class="o">=</span> <span class="n">kernel</span>  <span class="c1"># 解包核中的PSF和背景</span>
    <span class="n">psf_params</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># 初始化PSF参数字典</span>

    <span class="k">for</span> <span class="n">pname</span><span class="p">,</span> <span class="n">pvalue</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">psf0</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">psf0</span><span class="o">.</span><span class="n">parameters</span><span class="p">):</span>  <span class="c1"># 遍历PSF参数</span>
        <span class="k">if</span> <span class="n">pname</span> <span class="o">==</span> <span class="n">trace_center_param</span><span class="p">:</span>  <span class="c1"># 如果参数是轨迹中心参数</span>
            <span class="n">psf_params</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace_centers</span>  <span class="c1"># 使用轨迹中心</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psf_params</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">)</span>  <span class="c1"># 其他参数填充为常数</span>

    <span class="n">psf_set</span> <span class="o">=</span> <span class="n">psf0</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">n_models</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="o">**</span><span class="n">psf_params</span><span class="p">)</span>  <span class="c1"># 创建新的PSF模型集</span>

    <span class="c1"># 如果不使用Polynomial1D作为背景模型，请编辑此部分：</span>
    <span class="n">bg_set</span> <span class="o">=</span> <span class="n">bg0</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bg0</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_models</span><span class="o">=</span><span class="n">nx</span><span class="p">)</span>  <span class="c1"># 创建背景模型集</span>

    <span class="k">for</span> <span class="n">pname</span><span class="p">,</span> <span class="n">pvalue</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bg0</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">bg0</span><span class="o">.</span><span class="n">parameters</span><span class="p">):</span>  <span class="c1"># 遍历背景参数</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">bg_set</span><span class="p">,</span> <span class="n">pname</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">))</span>  <span class="c1"># 将背景参数填充为常数</span>

    <span class="n">kernel_set</span> <span class="o">=</span> <span class="n">psf_set</span> <span class="o">+</span> <span class="n">bg_set</span>  <span class="c1"># 合并PSF和背景模型集</span>

    <span class="c1"># 我们传递model_set_axis=False，以便模型集中每个模型使用相同的输入，</span>
    <span class="c1"># 并转置结果以修正方向。</span>
    <span class="n">kernel_image</span> <span class="o">=</span> <span class="n">kernel_set</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># 计算核图像</span>
    
    <span class="c1"># 现在我们使用numpy.ma例程执行加权求和，以保留我们的掩码</span>
    <span class="c1"># 单位归一化核，遵循Horne1986公式5，P_x = P/sum(P_x)。 </span>
    <span class="n">kernel_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">kernel_image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  <span class="c1"># 遮蔽非正值</span>
    <span class="n">kernel_image</span> <span class="o">=</span> <span class="n">kernel_image</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_image</span><span class="p">)</span>  <span class="c1"># 归一化核图像</span>
    
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_image</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">variance_image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 计算归一化因子</span>
    <span class="n">weighted_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">kernel_image</span> <span class="o">*</span> <span class="n">extraction_region</span><span class="p">,</span> <span class="n">variance_image</span><span class="p">)</span>  <span class="c1"># 计算加权光谱</span>
    <span class="n">spectrum1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weighted_spectrum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>  <span class="c1"># 计算1D光谱</span>
    
    <span class="c1"># 将任何被遮蔽的值设置为0。</span>
    <span class="k">return</span> <span class="n">spectrum1d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>  <span class="c1"># 返回填充后的光谱</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id23">
<h3>便利函数<a class="headerlink" href="#id23" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">batch_wavelength_from_wcs</span><span class="p">(</span><span class="n">datamodel</span><span class="p">,</span> <span class="n">pix_x</span><span class="p">,</span> <span class="n">pix_y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    从数据模型的元数据中获取WCS对象， </span>
<span class="sd">    根据给定的像素坐标生成世界坐标，并返回1D波长。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">wcs</span> <span class="o">=</span> <span class="n">datamodel</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">wcs</span>  <span class="c1"># 获取WCS对象</span>
    <span class="n">aC</span><span class="p">,</span> <span class="n">dC</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">wcs</span><span class="p">(</span><span class="n">pix_x</span><span class="p">,</span> <span class="n">pix_y</span><span class="p">)</span>  <span class="c1"># 将像素坐标转换为世界坐标</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 返回第一个波长值</span>

<span class="k">def</span><span class="w"> </span><span class="nf">batch_save_extracted_spectrum</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    提取光谱的快速FITS输出。</span>
<span class="sd">    替换为您首选的输出格式和函数。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">wcol</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;wavelength&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;E&#39;</span><span class="p">,</span>  <span class="c1"># 创建波长列</span>
                       <span class="n">array</span><span class="o">=</span><span class="n">wavelength</span><span class="p">)</span>  <span class="c1"># 设置波长数组</span>
    <span class="n">scol</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;spectrum&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;E&#39;</span><span class="p">,</span>  <span class="c1"># 创建光谱列</span>
                       <span class="n">array</span><span class="o">=</span><span class="n">spectrum</span><span class="p">)</span>  <span class="c1"># 设置光谱数组</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">ColDefs</span><span class="p">([</span><span class="n">wcol</span><span class="p">,</span> <span class="n">scol</span><span class="p">])</span>  <span class="c1"># 定义列</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>  <span class="c1"># 创建二进制表HDU</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 将HDU写入文件，覆盖同名文件</span>

<span class="k">def</span><span class="w"> </span><span class="nf">batch_plot_output</span><span class="p">(</span><span class="n">resampled_image</span><span class="p">,</span> <span class="n">extraction_bbox</span><span class="p">,</span> 
                      <span class="n">kernel_slice</span><span class="p">,</span> <span class="n">kernel_model</span><span class="p">,</span>
                      <span class="n">wavelength</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    方便的汇总输出图形， </span>
<span class="sd">    允许对每个处理文件的结果进行可视检查。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ax3</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>  <span class="c1"># 创建3行1列的子图</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>  <span class="c1"># 设置图形标题</span>
    
    <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">resampled_image</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># 获取重采样图像的形状</span>
    <span class="n">aspect</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ny</span><span class="p">)</span>  <span class="c1"># 计算纵横比</span>
    
    <span class="c1"># 子图1：提取区域</span>
    <span class="n">power_norm</span> <span class="o">=</span> <span class="n">simple_norm</span><span class="p">(</span><span class="n">resampled_image</span><span class="p">,</span> <span class="s1">&#39;power&#39;</span><span class="p">)</span>  <span class="c1"># 归一化图像</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">resampled_image</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                   <span class="n">aspect</span><span class="o">=</span><span class="n">aspect</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">power_norm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>  <span class="c1"># 显示重采样图像</span>
    <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">rh</span> <span class="o">=</span> <span class="n">extraction_bbox</span>  <span class="c1"># 解包提取边界框</span>
    <span class="n">region</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">((</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">),</span> <span class="n">rw</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> 
                       <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>  <span class="c1"># 创建提取区域矩形</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>  <span class="c1"># 将矩形添加到子图1</span>
    
    <span class="c1"># 子图2：核拟合</span>
    <span class="n">xd_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">kernel_slice</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># 创建像素索引</span>
    <span class="n">fit_line</span> <span class="o">=</span> <span class="n">kernel_model</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">)</span>  <span class="c1"># 计算拟合线</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">kernel_slice</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Kernel Slice&#39;</span><span class="p">)</span>  <span class="c1"># 绘制核切片</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xd_pixels</span><span class="p">,</span> <span class="n">fit_line</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Extraction Kernel&#39;</span><span class="p">)</span>  <span class="c1"># 绘制提取核</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>  <span class="c1"># 添加图例</span>
    
    <span class="c1"># 子图3：提取的光谱</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)</span>  <span class="c1"># 绘制光谱</span>
    
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>  <span class="c1"># 保存图形</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>  <span class="c1"># 关闭图形</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id24">
<h3>遍历所需文件<a class="headerlink" href="#id24" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">batch_optimal_extraction</span><span class="p">(</span><span class="n">file_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    遍历一个fits文件路径的列表，优化提取每个文件中的SCI扩展，</span>
<span class="sd">    生成输出摘要图像，然后保存结果光谱。</span>

<span class="sd">    注意，在示例数据集中，每个文件中只有一个SCI扩展。</span>
<span class="sd">    对于具有多个SCI扩展的数据，需要对这些扩展进行第二次循环。</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 对于这个示例数据，我们将使用所有函数的默认值</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fitsfile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">file_list</span><span class="p">):</span>
        <span class="c1"># 打印当前处理的文件信息</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing file </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">),</span> <span class="n">fitsfile</span><span class="p">))</span>

        <span class="c1"># 创建图像模型对象，读取fits文件</span>
        <span class="n">dmodel</span> <span class="o">=</span> <span class="n">ImageModel</span><span class="p">(</span><span class="n">fitsfile</span><span class="p">)</span>

        <span class="c1"># 获取数据和权重</span>
        <span class="n">spec2d</span> <span class="o">=</span> <span class="n">dmodel</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># 获取二维光谱数据</span>
        <span class="n">wht2d</span> <span class="o">=</span> <span class="n">dmodel</span><span class="o">.</span><span class="n">wht</span>    <span class="c1"># 获取权重数据</span>

        <span class="c1"># 批量获取光谱的核切片</span>
        <span class="n">k_slice</span> <span class="o">=</span> <span class="n">batch_kernel_slice</span><span class="p">(</span><span class="n">spec2d</span><span class="p">)</span>

        <span class="c1"># 批量拟合提取核</span>
        <span class="n">k_model</span> <span class="o">=</span> <span class="n">batch_fit_extraction_kernel</span><span class="p">(</span><span class="n">k_slice</span><span class="p">)</span>

        <span class="c1"># 批量拟合轨迹中心</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">batch_fit_trace_centers</span><span class="p">(</span><span class="n">spec2d</span><span class="p">,</span> <span class="n">k_model</span><span class="p">)</span>

        <span class="c1"># 批量提取光谱</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">batch_extract_spectrum</span><span class="p">(</span><span class="n">spec2d</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">k_model</span><span class="p">,</span> <span class="n">wht2d</span><span class="p">)</span>

        <span class="c1"># 获取光谱数据的形状</span>
        <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">spec2d</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># 创建二维网格</span>
        <span class="n">y2d</span><span class="p">,</span> <span class="n">x2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">ny</span><span class="p">,</span> <span class="p">:</span><span class="n">nx</span><span class="p">]</span>

        <span class="c1"># 从WCS获取波长</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="n">batch_wavelength_from_wcs</span><span class="p">(</span><span class="n">dmodel</span><span class="p">,</span> <span class="n">x2d</span><span class="p">,</span> <span class="n">y2d</span><span class="p">)</span>

        <span class="c1"># 定义边界框</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># 生成输出文件名</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">fitsfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;s2d.fits&#39;</span><span class="p">,</span> <span class="s1">&#39;x1d_optimal&#39;</span><span class="p">)</span>

        <span class="c1"># 绘制输出图像并保存</span>
        <span class="n">batch_plot_output</span><span class="p">(</span><span class="n">spec2d</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">k_slice</span><span class="p">,</span> <span class="n">k_model</span><span class="p">,</span>
                          <span class="n">wavelength</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> 
                          <span class="n">outfile</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">)</span>

        <span class="c1"># 保存提取的光谱到fits文件</span>
        <span class="n">batch_save_extracted_spectrum</span><span class="p">(</span><span class="n">outfile</span><span class="o">+</span><span class="s1">&#39;.fits&#39;</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id25">
<h3>在示例数据集上运行<a class="headerlink" href="#id25" title="Link to this heading">#</a></h3>
<p>请特别注意在拟合过程中产生警告的任何光谱 - 这些光谱很可能是交互式重处理的良好候选者。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>  <span class="c1"># 如果不关闭这个选项，matplotlib会尝试为每个光谱显示一个（不可见的）图</span>

<span class="n">s2d_files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;s2d_files&#39;</span><span class="p">,</span> <span class="s1">&#39;*s2d.fits&#39;</span><span class="p">))</span>  <span class="c1"># 获取所有s2d.fits文件的路径</span>

<span class="n">batch_optimal_extraction</span><span class="p">(</span><span class="n">s2d_files</span><span class="p">)</span>  <span class="c1"># 对获取的s2d文件进行批量最优提取</span>

<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>  <span class="c1"># 现在重新打开这个选项，以便后续的图形能够正常显示！</span>
</pre></div>
</div>
</div>
</div>
<p>看起来您没有提供任何Markdown内容。如果您有需要翻译的文本，请将其粘贴在这里，我将很乐意为您翻译。</p>
</section>
</section>
<section id="b-stpsf">
<h2>附录 B: STPSF<a class="headerlink" href="#b-stpsf" title="Link to this heading">#</a></h2>
<p>我们可以直接通过仪器模型使用 <a class="reference external" href="https://stpsf.readthedocs.io/en/latest/index.html">STPSF</a> 生成点扩散函数（PSF），而不是使用PSF模板。</p>
<p>STPSF的主要功能是生成成像PSF；然而，它<em>可以</em>生成一组单色PSF，我们可以将这些PSF进行组合。</p>
<p><code class="docutils literal notranslate"><span class="pre">stpsf</span></code> 仅在此处需要，因此我们在本附录的开头导入它：</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">stpsf</span><span class="w"> </span><span class="kn">import</span> <span class="n">NIRSpec</span><span class="p">,</span> <span class="n">display_psf</span>  <span class="c1"># 从stpsf模块导入NIRSpec类和display_psf函数</span>
</pre></div>
</div>
</div>
</div>
<section id="id26">
<h3>仪器属性<a class="headerlink" href="#id26" title="Link to this heading">#</a></h3>
<p>有关仪器设置的完整列表，请参见 STPSF 文档。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">instrument</span> <span class="o">=</span> <span class="n">NIRSpec</span><span class="p">()</span>  <span class="c1"># 创建NIRSpec仪器的实例</span>

<span class="nb">print</span><span class="p">(</span><span class="n">instrument</span><span class="o">.</span><span class="n">filter_list</span><span class="p">)</span>  <span class="c1"># 打印仪器可用的滤光片列表</span>

<span class="c1"># 参考：允许的掩模列表</span>
<span class="n">allowed_masks</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;S200A1&#39;</span><span class="p">,</span> <span class="s1">&#39;S200A2&#39;</span><span class="p">,</span> <span class="s1">&#39;S400A1&#39;</span><span class="p">,</span> <span class="s1">&#39;S1600A1&#39;</span><span class="p">,</span> <span class="s1">&#39;S200B1&#39;</span><span class="p">,</span> 
                 <span class="s1">&#39;MSA all open&#39;</span><span class="p">,</span> <span class="s1">&#39;Single MSA open shutter&#39;</span><span class="p">,</span> 
                 <span class="s1">&#39;Three adjacent MSA open shutters&#39;</span><span class="p">)</span>  <span class="c1"># 定义允许的掩模选项</span>

<span class="c1"># 根据需要编辑这些参数</span>
<span class="n">instrument</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="s1">&#39;F110W&#39;</span>  <span class="c1"># 设置仪器的滤光片为F110W</span>
<span class="n">instrument</span><span class="o">.</span><span class="n">image_mask</span> <span class="o">=</span> <span class="s1">&#39;Three adjacent MSA open shutters&#39;</span>  <span class="c1"># 设置图像掩模为三个相邻的MSA开放快门</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="psfs">
<h3>单色点扩散函数（PSFs）<a class="headerlink" href="#psfs" title="Link to this heading">#</a></h3>
<p>我们可以使用的最严格的方法是为2D光谱中的每个波长生成一个点扩散函数（PSF），并将它们全部结合。然而，这种方法所需的计算时间和内存通常非常大，除非光谱在色散方向上相当短。一个更合理的方法（这正是我们在这里要做的）是创建一组均匀间隔的单色点扩散函数，并在它们之间进行插值。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psf_wavelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">wavelength</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wavelength</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0e-6</span>  <span class="c1"># 生成从最小波长到最大波长的10个波长值，单位转换为米</span>

<span class="n">cube_hdul</span> <span class="o">=</span> <span class="n">instrument</span><span class="o">.</span><span class="n">calc_datacube</span><span class="p">(</span><span class="n">psf_wavelengths</span><span class="p">)</span>  <span class="c1"># 计算数据立方体，输出为HDUList对象</span>

<span class="n">psf_cube</span> <span class="o">=</span> <span class="n">cube_hdul</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># 从HDUList中提取数据立方体的实际数据</span>

<span class="n">psf_cube</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># 获取数据立方体的形状</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 显示数据立方体的内容</span>

<span class="n">fig9</span><span class="p">,</span> <span class="n">ax9</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>  <span class="c1"># 创建一个5行2列的子图，图形大小为8x12英寸</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mf">0.06</span><span class="p">,</span>  <span class="c1"># 调整子图之间的间距和边距</span>
                    <span class="n">right</span><span class="o">=</span><span class="mf">0.94</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.95</span><span class="p">)</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>  <span class="c1"># 遍历行</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># 遍历列</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">ax9</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>  <span class="c1"># 获取当前子图的坐标轴</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">row</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">col</span>  <span class="c1"># 计算当前的波长索引</span>

        <span class="n">wl</span> <span class="o">=</span> <span class="n">psf_wavelengths</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>  <span class="c1"># 获取对应的波长</span>
        
        <span class="c1"># 显示当前波长的点扩散函数（PSF）</span>
        <span class="n">display_psf</span><span class="p">(</span><span class="n">cube_hdul</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cube_slice</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s2">&quot;$\lambda$ = </span><span class="si">{:.3f}</span><span class="s2"> $\mu$m&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wl</span><span class="o">*</span><span class="mf">1e6</span><span class="p">),</span>  <span class="c1"># 设置标题，显示波长</span>
                    <span class="n">vmax</span><span class="o">=</span><span class="mf">.2</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 设置显示的最大值和最小值，不显示颜色条</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏x轴</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏y轴</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id27">
<h3>插值方法<a class="headerlink" href="#id27" title="Link to this heading">#</a></h3>
<p>我们选择的插值方法在很大程度上取决于点扩散函数（PSF）如何随波长变化。为了评估不同的方法，我们将创建另一个单色点扩散函数（PSF）进行比较。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 计算给定波长（3.0微米）的点扩散函数（PSF）</span>
<span class="n">reference_psf_hdul</span> <span class="o">=</span> <span class="n">instrument</span><span class="o">.</span><span class="n">calc_psf</span><span class="p">(</span><span class="n">monochromatic</span><span class="o">=</span><span class="mf">3.0e-6</span><span class="p">)</span>

<span class="c1"># 从PSF数据中提取第二个HDU（Header Data Unit）的数据</span>
<span class="n">reference_psf</span> <span class="o">=</span> <span class="n">reference_psf_hdul</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

<span class="c1"># 使用简单归一化方法对PSF进行归一化，采用对数伸缩，设置最小值和最大值</span>
<span class="n">ref_norm</span> <span class="o">=</span> <span class="n">simple_norm</span><span class="p">(</span><span class="n">reference_psf</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>最简单的方法是进行三维线性插值，接下来我们来看看效果如何。在下图中，左上角的图像是参考点扩散函数（PSF），右上角是线性插值后的点扩散函数，左下角是差异图像，右下角是参考（X）和插值（Y）点扩散函数的对数-对数图。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ref_pix</span> <span class="o">=</span> <span class="n">reference_psf</span> <span class="o">&gt;=</span> <span class="mf">1e-4</span>  <span class="c1"># 创建一个布尔数组，标记参考PSF中大于等于1e-4的像素</span>

<span class="n">psf_x</span> <span class="o">=</span> <span class="n">psf_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">48</span><span class="p">)</span>  <span class="c1"># 创建一个包含48个元素的数组，用于PSF的x和y坐标</span>

<span class="n">out_x</span><span class="p">,</span> <span class="n">out_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">psf_x</span><span class="p">,</span> <span class="n">psf_y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>  <span class="c1"># 创建网格坐标，用于插值</span>

<span class="n">interpolator</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">((</span><span class="n">psf_wavelengths</span><span class="p">,</span> <span class="n">psf_x</span><span class="p">,</span> <span class="n">psf_y</span><span class="p">),</span> <span class="n">psf_cube</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>  <span class="c1"># 创建线性插值器</span>

<span class="n">linear_psf</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">((</span><span class="mf">3.0e-6</span><span class="p">,</span> <span class="n">out_x</span><span class="p">,</span> <span class="n">out_y</span><span class="p">))</span>  <span class="c1"># 使用插值器计算给定波长下的线性PSF</span>

<span class="n">diff_lin_psf</span> <span class="o">=</span> <span class="n">reference_psf</span> <span class="o">-</span> <span class="n">linear_psf</span>  <span class="c1"># 计算参考PSF与线性PSF之间的差异</span>

<span class="c1"># 打印参考PSF的最小值和最大值</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reference: min </span><span class="si">{:.3e}</span><span class="s2">, max </span><span class="si">{:.3e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference_psf</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">reference_psf</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

<span class="c1"># 打印线性PSF的最小值和最大值</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Linear: min </span><span class="si">{:.3e}</span><span class="s2">, max </span><span class="si">{:.3e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">linear_psf</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">linear_psf</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

<span class="c1"># 打印差异PSF的最小值和最大值</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Diff: min </span><span class="si">{:.3e}</span><span class="s2">, max </span><span class="si">{:.3e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diff_lin_psf</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">diff_lin_psf</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

<span class="c1"># 打印总误差，计算差异PSF的平方和的平方根</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total error: </span><span class="si">{:.5e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">diff_lin_psf</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())))</span>

<span class="c1"># 创建一个2x2的子图</span>
<span class="n">figA</span><span class="p">,</span> <span class="n">axA</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.95</span><span class="p">)</span>  <span class="c1"># 调整子图之间的间距</span>

<span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">reference_psf</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ref_norm</span><span class="p">)</span>  <span class="c1"># 显示参考PSF图像</span>
<span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏x轴</span>
<span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏y轴</span>

<span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">linear_psf</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ref_norm</span><span class="p">)</span>  <span class="c1"># 显示线性PSF图像</span>
<span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏x轴</span>
<span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏y轴</span>

<span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">diff_lin_psf</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mf">5e-4</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">)</span>  <span class="c1"># 显示差异PSF图像</span>
<span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏x轴</span>
<span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏y轴</span>

<span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">reference_psf</span><span class="p">[</span><span class="n">ref_pix</span><span class="p">],</span> <span class="n">linear_psf</span><span class="p">[</span><span class="n">ref_pix</span><span class="p">],</span> <span class="s1">&#39;k+&#39;</span><span class="p">)</span>  <span class="c1"># 在对数坐标系中绘制参考PSF与线性PSF的关系</span>
<span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">)</span>  <span class="c1"># 设置坐标轴比例相等</span>
</pre></div>
</div>
</div>
</div>
<p>下一个方法计算量更大，但可能更准确。我们逐像素遍历PSF立方体，并沿着波长轴使用一维三次样条插值。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cubic_psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">psf_cube</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 创建一个与psf_cube第一层相同形状的零数组，用于存储立方插值结果</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">48</span><span class="p">):</span>  <span class="c1"># 遍历行</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">48</span><span class="p">):</span>  <span class="c1"># 遍历列</span>

        <span class="n">spline</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">psf_wavelengths</span><span class="p">,</span> <span class="n">psf_cube</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>  <span class="c1"># 对每个像素的光谱数据进行立方插值</span>

        <span class="n">cubic_psf</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="mf">3.0e-6</span><span class="p">)</span>  <span class="c1"># 在指定波长处计算插值并存储结果</span>

        

<span class="n">diff_cub_psf</span> <span class="o">=</span> <span class="n">reference_psf</span> <span class="o">-</span> <span class="n">cubic_psf</span>  <span class="c1"># 计算参考PSF与立方插值PSF之间的差异</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reference: min </span><span class="si">{:.3e}</span><span class="s2">, max </span><span class="si">{:.3e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference_psf</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">reference_psf</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>  <span class="c1"># 打印参考PSF的最小值和最大值</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cubic: min </span><span class="si">{:.3e}</span><span class="s2">, max </span><span class="si">{:.3e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cubic_psf</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">cubic_psf</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>  <span class="c1"># 打印立方插值PSF的最小值和最大值</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Diff: min </span><span class="si">{:.3e}</span><span class="s2">, max </span><span class="si">{:.3e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diff_cub_psf</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">diff_cub_psf</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>  <span class="c1"># 打印差异PSF的最小值和最大值</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total error: </span><span class="si">{:.5e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">diff_cub_psf</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())))</span>  <span class="c1"># 计算并打印总误差（均方根误差）</span>

 

<span class="n">figB</span><span class="p">,</span> <span class="n">axB</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>  <span class="c1"># 创建一个2x2的子图</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.95</span><span class="p">)</span>  <span class="c1"># 调整子图之间的间距</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">reference_psf</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ref_norm</span><span class="p">)</span>  <span class="c1"># 显示参考PSF图像</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏x轴</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏y轴</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cubic_psf</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ref_norm</span><span class="p">)</span>  <span class="c1"># 显示立方插值PSF图像</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏x轴</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏y轴</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">diff_cub_psf</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mf">5e-4</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">)</span>  <span class="c1"># 显示差异PSF图像，设置颜色范围</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏x轴</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># 隐藏y轴</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">reference_psf</span><span class="p">[</span><span class="n">ref_pix</span><span class="p">],</span> <span class="n">cubic_psf</span><span class="p">[</span><span class="n">ref_pix</span><span class="p">],</span> <span class="s1">&#39;k+&#39;</span><span class="p">)</span>  <span class="c1"># 在对数坐标系中绘制参考PSF与立方插值PSF的关系</span>

<span class="n">axB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">)</span>  <span class="c1"># 设置坐标轴比例相等</span>
</pre></div>
</div>
</div>
</div>
<p>虽然对数-对数（log-log）图看起来与线性情况几乎相同，但在样条（spline）情况下的差异图显示某些中心像素的误差略大。这与“总误差”（total error）统计量（差异图的平方和）一致，在第二种情况下更大。</p>
<p>我们可以在下面的图中看到，这两种方法之间的差异非常小，但线性插值（linearly-interpolated）点扩散函数（PSF）的总误差大约准确了~3倍。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figC</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c1"># 创建一个新的图形对象</span>

<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">linear_psf</span><span class="p">[</span><span class="n">ref_pix</span><span class="p">],</span> <span class="n">cubic_psf</span><span class="p">[</span><span class="n">ref_pix</span><span class="p">],</span> <span class="s1">&#39;k+&#39;</span><span class="p">)</span>  <span class="c1"># 在对数坐标系中绘制线性插值和立方插值的点，使用黑色加号标记</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Linear interpolation&#39;</span><span class="p">)</span>  <span class="c1"># 设置x轴标签为“线性插值”</span>

<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Cubic interpolation&#39;</span><span class="p">)</span>  <span class="c1"># 设置y轴标签为“立方插值”</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id28">
<h3>完整的轨迹点扩散函数 (PSF)<a class="headerlink" href="#id28" title="Link to this heading">#</a></h3>
<p>现在我们可以为光谱轨迹生成一个完整的点扩散函数 (PSF)。请注意，在每个波长下，PSF将是重叠的相邻单色PSF的线性组合。如果存在几何畸变，在拟合轨迹中心之后生成这个PSF可能会更有利。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建一个三维网格，分别对应波长、PSF的x和y坐标</span>
<span class="n">cube_w</span><span class="p">,</span> <span class="n">cube_x</span><span class="p">,</span> <span class="n">cube_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">wavelength</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">psf_x</span><span class="p">,</span> <span class="n">psf_y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

<span class="c1"># 使用插值器生成完整的PSF立方体</span>
<span class="n">full_psf_cube</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">((</span><span class="n">cube_w</span><span class="p">,</span> <span class="n">cube_x</span><span class="p">,</span> <span class="n">cube_y</span><span class="p">))</span>

<span class="c1"># 获取PSF立方体的形状</span>
<span class="n">nw</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">full_psf_cube</span><span class="o">.</span><span class="n">shape</span>

<span class="c1"># 计算y维度的一半，用于后续索引</span>
<span class="n">half</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">//</span> <span class="mi">2</span>

<span class="c1"># 初始化一个二维数组，用于存储追踪数据</span>
<span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nw</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="c1"># 遍历每个波长和对应的PSF</span>
<span class="k">for</span> <span class="n">wl</span><span class="p">,</span> <span class="n">psf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">full_psf_cube</span><span class="p">):</span>
    <span class="c1"># 计算当前波长的下界索引</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">wl</span> <span class="o">-</span> <span class="n">half</span>

    <span class="c1"># 确保下界索引不小于0</span>
    <span class="n">lo_w</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># 计算下界的x坐标索引</span>
    <span class="n">lo_x</span> <span class="o">=</span> <span class="n">lo_w</span> <span class="o">-</span> <span class="n">lo</span>

    <span class="c1"># 计算当前波长的上界索引</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">wl</span> <span class="o">+</span> <span class="n">half</span>

    <span class="c1"># 确保上界索引不超过nw</span>
    <span class="n">hi_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="n">nw</span><span class="p">)</span>

    <span class="c1"># 计算上界的x坐标索引</span>
    <span class="n">hi_x</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">-</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">hi_w</span><span class="p">)</span>

    <span class="c1"># 将当前PSF的值累加到trace数组的相应位置</span>
    <span class="n">trace</span><span class="p">[:,</span> <span class="n">lo_w</span><span class="p">:</span><span class="n">hi_w</span><span class="p">]</span> <span class="o">+=</span> <span class="n">psf</span><span class="p">[:,</span> <span class="n">lo_x</span><span class="p">:</span><span class="n">hi_x</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">wpsf_aspect</span> <span class="o">=</span> <span class="n">nw</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">ny</span><span class="p">)</span>  <span class="c1"># 计算宽度与高度的比例，用于设置图像的纵横比</span>

<span class="n">figD</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>  <span class="c1"># 创建一个新的图形，设置图形大小为10x8英寸</span>

<span class="n">trace_norm</span> <span class="o">=</span> <span class="n">simple_norm</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># 对数据进行归一化处理，使用对数伸缩，设置最小值和最大值</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">wpsf_aspect</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">trace_norm</span><span class="p">)</span>  <span class="c1"># 显示图像，设置插值方式、纵横比和归一化</span>

<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>  <span class="c1"># 添加颜色条以显示数据值的颜色映射</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id29">
<h3>重采样轨迹<a class="headerlink" href="#id29" title="Link to this heading">#</a></h3>
<p>目前，我们的点扩散函数（PSF）数组的大小和位置与提取区域中的轨迹不一致。虽然我们可以通过移动和裁剪来调整到正确的大小，但光谱通常不会恰好位于一个像素中心，并且由于采样不足，PSF中的分数像素偏移可能会导致最终提取中出现显著误差。因此，我们将对光谱在提取区域中的位置进行最终重采样。为此，我们可以使用我们熟悉的 <code class="docutils literal notranslate"><span class="pre">RegularGridInterpolator</span></code>。我们将STPSF轨迹的中心（最初位于第23行）设置为我们的拟合轨迹中心，并进行适当的重采样。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trace_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>  <span class="c1"># 创建一个从0到ny的数组，表示行索引</span>

<span class="n">trace_interpolator</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">((</span><span class="n">trace_row</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">),</span> <span class="n">trace</span><span class="p">)</span>  <span class="c1"># 创建一个正则网格插值器，用于插值trace数据</span>

<span class="n">center_0</span> <span class="o">=</span> <span class="mi">23</span>  <span class="c1"># 定义中心位置0</span>

<span class="n">center_1</span> <span class="o">=</span> <span class="n">fit_extraction_kernel</span><span class="o">.</span><span class="n">mean_0</span>  <span class="c1"># 从拟合提取核中获取中心位置1</span>

<span class="n">out_lo</span> <span class="o">=</span> <span class="n">center_0</span> <span class="o">-</span> <span class="n">center_1</span>  <span class="c1"># 计算输出的下限</span>

<span class="n">out_hi</span> <span class="o">=</span> <span class="n">out_lo</span> <span class="o">+</span> <span class="n">er_ny</span>  <span class="c1"># 计算输出的上限</span>

<span class="n">resample_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">out_lo</span><span class="p">,</span> <span class="n">out_hi</span><span class="p">,</span> <span class="n">er_ny</span><span class="p">)</span>  <span class="c1"># 在下限和上限之间生成均匀的重采样行</span>

<span class="n">resample_y</span><span class="p">,</span> <span class="n">resample_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">resample_row</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>  <span class="c1"># 创建重采样的y和w网格</span>

<span class="n">resampled_trace</span> <span class="o">=</span> <span class="n">trace_interpolator</span><span class="p">((</span><span class="n">resample_y</span><span class="p">,</span> <span class="n">resample_w</span><span class="p">))</span>  <span class="c1"># 使用插值器对重采样的y和w进行插值，得到重采样的trace</span>

<span class="n">figE</span><span class="p">,</span> <span class="n">axE</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>  <span class="c1"># 创建一个包含2行1列的子图</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># 调整子图之间的垂直间距</span>

<span class="n">trace_renorm</span> <span class="o">=</span> <span class="n">simple_norm</span><span class="p">(</span><span class="n">resampled_trace</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>  <span class="c1"># 对重采样的trace进行简单归一化，使用对数伸缩</span>

<span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">resampled_trace</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">trace_renorm</span><span class="p">)</span>  <span class="c1"># 在第一个子图中显示重采样的trace</span>

<span class="n">axE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">extraction_region</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span>  <span class="c1"># 在第二个子图中显示提取区域</span>
              <span class="n">norm</span><span class="o">=</span><span class="n">er_norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>  <span class="c1"># 使用灰度色图和指定的归一化</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="id30">
<h2>关于这个笔记本<a class="headerlink" href="#id30" title="Link to this heading">#</a></h2>
<p><strong>作者：</strong> Graham Kanarek，科学支持部门的工作人员科学家</p>
<p><strong>更新时间：</strong> 2025-02-27，使用 STPSF 代替 WebbPSF。</p>
<p>最佳提取算法改编自 <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/1986PASP...98..609H/">Horne (1986)</a>。</p>
<p>看起来您没有提供任何内容需要翻译。如果您有特定的Markdown内容需要翻译，请将其粘贴在这里，我将很高兴为您提供帮助。</p>
<p><a class="reference internal" href="#top"><span class="xref myst">页面顶部</span></a></p>
<a class="reference internal image-reference" href="https://raw.githubusercontent.com/spacetelescope/notebooks/master/assets/stsci_pri_combo_mark_horizonal_white_bkgd.png"><img alt="空间望远镜标志" src="https://raw.githubusercontent.com/spacetelescope/notebooks/master/assets/stsci_pri_combo_mark_horizonal_white_bkgd.png" style="width: 200px;" />
</a>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks/NIRSpec/optimal_extraction"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../ifu_optimal/ifu_optimal_cn.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">NIRSpec IFU 最优点源提取</p>
      </div>
    </a>
    <a class="right-next"
       href="../mos_spectroscopy_advanced/MOSspec_advanced_cn.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">星系外场的MOS光谱</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">引言</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">定义术语</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">导入库</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">加载数据</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">最优提取算法</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">定义提取区域</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">创建核切片</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">定义提取核</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#psf">选择一个PSF模板</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">多项式背景</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">拟合提取核</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fwhm">波长变化的全宽半最大值 (FWHM)（已跳过）</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">拟合几何畸变 <em>(跳过)</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">定义轨迹拟合的区间</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">使用修改后的提取核拟合每个箱体</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">使用一维多项式拟合轨迹中心</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#d">构建最终的1D光谱</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">创建方差图像</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">生成一维光谱</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a">附录 A：批处理</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">定义提取区域</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">创建核切片</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">创建并拟合提取核</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">考虑变化的全宽半最大值（FWHM）</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">拟合轨迹中心</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">生成一维光谱</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">便利函数</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">遍历所需文件</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">在示例数据集上运行</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#b-stpsf">附录 B: STPSF</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id26">仪器属性</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#psfs">单色点扩散函数（PSFs）</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id27">插值方法</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id28">完整的轨迹点扩散函数 (PSF)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id29">重采样轨迹</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id30">关于这个笔记本</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By STScI
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022-2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>